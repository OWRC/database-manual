---
title:  "Appendix G.27"
author: "ormgpmd"
date:   "20220204"
output: html_document
knit:   (
            function(input_file, encoding) {
                out_dir <- '';
                rmarkdown::render(
                    input_file,
                    encoding=encoding,
                    output_file=file.path(dirname(input_file), out_dir,
                    'G_27.html')
                )
            }
        )
---

## G.27 York Database - Incorporation of Temporal Data

* Tables
    + D_INTERVAL_ALIAS
    + D_INTERVAL_TEMPORAL_1A
    + D_INTERVAL_TEMPORAL_1B
    + D_INTERVAL_TEMPORAL_2

* Estimated Recurrence Time: Based upon availability

In the absence of the SiteFX (EarthFX) merge tool, a methodology was developed and applied to incorporate temporal data found within the York database (YKDB) into the 'master' database (MADB).  Between the two databases, common locations and intervals have differing LOC_IDs and INT_IDs.  This has been examined (on dates leading up to, for example, each of '2015-09-30', '2015-10-02' and '2017-11-16') and the results incorporated into the D_INTERVAL_ALIAS table of the MADB (i.e. the INT_NAME_ALIAS will be the INT_ID of the interval within the YKDB) and given an INT_ALIAS_TYPE_CODE of '1' ('Matching INT_ID in the York database') or '2' ('Matching INT_ID in the York database - Not used').  These INT_IDs are then used (in the former case) as a basis for review of new temporal data.

Tables containing records to be copied into the MADB (matching, approximately, the format of D_INTERVAL_TEMPORAL_1A, D_INTERVAL_TEMPORAL_1B and D_INTERVAL_TEMPORAL_2) are created within the YKDB and then copied across to the 'temphold' database (TMPDB) for subsequent incorporation.  These are created (within the YKDB) through the use of a series of views which extract information from the various temporal tables as found in the YKDB.  All imports are provided with a distinctive DATA_ID (in the MADB D_DATA_SOURCE table) linking the imported information to a specific version/date of the YKDB.

These series of views created within the copy of the YKDB include, for D_INTERVAL_TEMPORAL_1A:

create view v_tr_dit1a as
select
t.int_id as ypdt_int_id
,t.york_int_id
,t2.ypdt_sam_id
,dit1a.sam_id as sam_id
,dit1a.sam_sample_name
,t2.ypdt_sam_sample_name
,dit1a.sam_sample_date
,dit1a.sam_analysis_date
,dit1a.sam_lab_sample_id
,t2.ypdt_sam_lab_sample_id
,dit1a.sam_lab_job_number
,t2.ypdt_sam_lab_job_number
,dit1a.sam_internal_id
,dit1a.sam_sample_name_ouom
,dit1a.sam_type_code
,t2.ypdt_sam_type_code
,dit1a.sam_sample_date_ouom
,dit1a.sam_comment
,dit1a.sam_data_file
,dit1a.sys_time_stamp
,dit1a.data_id
,row_number() over (order by dit1a.sam_id) as rkey
from 
yorkdb_20210503.dbo.d_interval_temporal_1a as dit1a
inner join 
-- this is the york-to-ypdt int_id conversion
(
select
dia.int_id
,cast(dia.int_name_alias as int) as york_int_id
from 
oak_20160831_master.dbo.d_interval_alias as dia
where dia.int_alias_type_code=1
) as t
on dit1a.int_id=t.york_int_id
left outer join 
-- this is the current contents of the master db
(
select
dit1a.int_id
,dit1a.sam_id as ypdt_sam_id
,dit1a.sam_sample_date 
,dit1a.sam_sample_name as ypdt_sam_sample_name
,dit1a.sam_lab_sample_id as ypdt_sam_lab_sample_id
,dit1a.sam_lab_job_number as ypdt_sam_lab_job_number
,dit1a.sam_type_code as ypdt_sam_type_code
from 
oak_20160831_master.dbo.d_interval_temporal_1a as dit1a
inner join oak_20160831_master.dbo.d_interval_alias as dia
on dit1a.int_id=dia.int_id
where 
dia.int_alias_type_code=1
) as t2
on t.int_id=t2.int_id and t2.sam_sample_date=dit1a.sam_sample_date and dit1a.sam_type_code=t2.ypdt_sam_type_code

Note that this extracts 'all' data from the YKDB; those not present in the MADB will have a NULL YPDT_SAM_ID.

For D_INTERVAL_TEMPORAL_1B, there is an issue matching the RD_NAME_CODEs between the databases.  As such, a view was created comparing the RD_NAME_OUOM to RD_NAME_DESCRIPTION (the latter is found in R_RD_NAME_CODE).

create view v_tr_rd_name_code as
select
t.rd_name_ouom
,case
when rrnc.rd_name_code is not null then rrnc.rd_name_code
when rrna.rd_name_code is not null then rrna.rd_name_code
else -9999
end as ypdt_rd_name_code
,case
when rrnc.rd_name_code is not null then rrnc.rd_name_description
when rrna.rd_name_code is not null then rrna.reading_name_alias
else '-9999'
end as ypdt_rd_name_description
from 
(
select
distinct( dit1b.rd_name_ouom ) as rd_name_ouom
from 
yorkdb_20210503.dbo.d_interval_temporal_1b as dit1b
inner join yorkdb_20210503.dbo.v_tr_dit1a as v
on dit1b.sam_id=v.sam_id
) as t
left outer join oak_20160831_master.dbo.r_rd_name_code as rrnc
on t.rd_name_ouom like rrnc.rd_name_description
left outer join oak_20160831_master.dbo.r_reading_name_alias as rrna
on t.rd_name_ouom like rrna.reading_name_alias

Unmatched names can either be added to R_READING_ALIAS (where the parameter already exists) or R_RD_NAME_CODE (if it does not); the tag '-9999' is used to signify this.  Similarly, the UNIT_CODE is also examined.

create view v_tr_unit_code as
select
t.rd_unit_ouom
,t.rcount
,case
when ruc.unit_code is not null then ruc.unit_code
else
case
when t.rd_unit_ouom = 'pH' then 32
when t.rd_unit_ouom = 'mV' then 106
end
end as ypdt_unit_code
,case
when ruc.unit_code is not null then ruc.unit_description
else
case
when t.rd_unit_ouom = 'pH' then 'pH Units'
when t.rd_unit_ouom = 'mV' then 'millivolts'
end
end as ypdt_unit_description 
from 
(
select
rd_unit_ouom
,count(*) as rcount
from 
yorkdb_20210503.dbo.d_interval_temporal_1b as d1b
inner join yorkdb_20210503.dbo.v_tr_dit1a as v
on d1b.sam_id=v.sam_id
group by 
rd_unit_ouom
) as t
left outer join oak_20160831_master.dbo.r_unit_code as ruc
on t.rd_unit_ouom = ruc.unit_description

The view for extracting information from D_INTERVAL_TEMPORAL_1B can now be created.

create view v_tr_dit1b as
select
d1b.sam_id
,v.ypdt_sam_id
,d1b.rd_value_qualifier
,d1b.rd_value
,vrnc.ypdt_rd_name_code
,vuc.ypdt_unit_code
,d1b.rd_mdl
,d1b.rd_rdl
,vrnc.ypdt_rd_name_description
,d1b.rd_value_ouom
,vuc.ypdt_unit_description
,d1b.rd_mdl_ouom
,d1b.rd_rdl_ouom
,d1b.rd_comment
,d1b.sys_record_id
,cast(null as integer) as ypdt_sys_record_id
,d1b.sys_time_stamp
,row_number() over (order by d1b.sys_record_id) as rkey
from 
yorkdb_20210503.dbo.d_interval_temporal_1b as d1b
inner join yorkdb_20210503.dbo.v_tr_dit1a as v
on d1b.sam_id=v.sam_id 
inner join yorkdb_20210503.dbo.v_tr_rd_name_code as vrnc
on d1b.rd_name_ouom=vrnc.rd_name_ouom
inner join yorkdb_20210503.dbo.v_tr_unit_code as vuc
on d1b.rd_unit_ouom=vuc.rd_unit_ouom

Four equivalent D_INTERVAL_TEMPORAL_2 tables reside in the YKDB (as of 20210503); a view to extract information must be created for each. 

These include D_INTERVAL_TEMPORAL_2, D_INTERVAL_TEMPORAL_EXT, D_INTERVAL_TEMPORAL_YORK and D_INTVL_TEMP2).  The basic structure for each are the same (the corresponding names are: V_TR_DIT2; V_TR_DITEXT; V_TR_DITYORK; and V_TR_DITVL2).

create view v_tr_dit2 as
select
t.int_id as ypdt_int_id
,t.york_int_id
,d.rd_date
,case 
    when d.rd_name_code=707 then 67
    when d.rd_name_code=711 then 85
    else null 
end as rd_type_code
,case
    when d.rd_name_code=163 then 71037 
    when d.rd_name_code=369 then 70871
    when d.rd_name_code=699 then 447
    when d.rd_name_code=700 then 629
    when d.rd_name_code=701 then 611
    when d.rd_name_code=702 then 612
    when d.rd_name_code=703 then 628
    when d.rd_name_code=706 then 70899
    when d.rd_name_code=707 then 70899
    when d.rd_name_code=711 then 629
    else null 
end as rd_name_code
,case 
    when d.unit_code=45 then d.rd_value*0.001
    else d.rd_value
end as rd_value
,case 
    when unit_code=45 then 74
    when unit_code=6  then 6
    when unit_code=3  then 3
    else null
end as unit_code
,d.rd_name_ouom
,d.rd_value_ouom
,d.rd_unit_ouom
,d.sys_record_id
,cast(null as integer) as ypdt_sys_record_id
--,row_number() over (order by d2.sys_record_id) as rkey
from 
yorkdb_20210503.dbo.d_interval_temporal_2 as d
inner join 
(
select
dia.int_id
,cast(dia.int_name_alias as int) as york_int_id
from 
oak_20160831_master.dbo.d_interval_alias as dia
where dia.int_alias_type_code=1
) as t
on d.int_id=t.york_int_id
where 
d.rd_name_code in (163,369,699,700,701,702,703,706,707)

Note that the RD_NAME_CODE and UNIT_CODE conversions are taking place entirely within the view itself.  The RD_TYPE_CODE field is unused in the YKDB but must be specified for the MADB to distinguish pump-on and pump-off conditions.

Due to the number of records (see below), the output from the views were written to a temporary database before determination of their new identifiers (to be used within the MADB) and final insertion.

For combining the three views for D_INTERVAL_TEMPORAL_2, an INTO statement and two insertions were used (with an increment for the row number in RKEY for each of the subsequent sources of information).  Note that in addition to checking whether there is 'new' data to be loaded, differences in 'existing' data (i.e. present in both the YKDB and MADB for the particular interval) are being included (to be incorporated as an update process).  For the latter, a range of values is used for comparison purposes.

D_INTERVAL_TEMPORAL_2

select
v.ypdt_int_id
,v.york_int_id
,v.sys_record_id
,v.ypdt_sys_record_id as ormgp_add_sys_record_id
,d.sys_record_id as ormgp_cur_sys_record_id
,v.rd_date
,v.rd_type_code
,v.rd_name_code
,v.rd_value
,d.rd_value as ormgp_cur_rd_value
,v.unit_code
,v.rd_name_ouom
,v.rd_value_ouom
,v.rd_unit_ouom
,row_number() over (order by v.sys_record_id) as rkey
into yorkdb_20210503.dbo.dit2
from 
yorkdb_20210503.dbo.v_tr_dit2 as v
left outer join oak_20160831_master.dbo.d_interval_temporal_2 as d
on v.ypdt_int_id=d.int_id and v.rd_date=d.rd_date and v.rd_name_code=d.rd_name_code
where 
v.rd_value is not null
and ( d.sys_record_id is null or (d.sys_record_id is not null and not( v.rd_value between (d.rd_value-0.001) and (d.rd_value+0.001) ) ) )

D_INTERVAL_TEMPORAL_EXT

insert into yorkdb_20210503.dbo.dit2
(
ypdt_int_id
,york_int_id
,sys_record_id
,ormgp_add_sys_record_id
,ormgp_cur_sys_record_id
,rd_date
,rd_type_code
,rd_name_code
,rd_value
,ormgp_cur_rd_value
,unit_code
,rd_name_ouom
,rd_value_ouom
,rd_unit_ouom
,rkey
)
select
v.ypdt_int_id
,v.york_int_id
,v.sys_record_id
,v.ypdt_sys_record_id as ormgp_add_sys_record_id
,d.sys_record_id as ormgp_cur_sys_record_id
,v.rd_date
,v.rd_type_code
,v.rd_name_code
,v.rd_value
,d.rd_value as ormgp_cur_rd_value
,v.unit_code
,v.rd_name_ouom
,v.rd_value_ouom
,v.rd_unit_ouom
,( row_number() over (order by v.sys_record_id) ) + 9645129 as rkey
from 
yorkdb_20210503.dbo.v_tr_ditext as v
left outer join oak_20160831_master.dbo.d_interval_temporal_2 as d
on v.ypdt_int_id=d.int_id and v.rd_date=d.rd_date and v.rd_name_code=d.rd_name_code 
where 
v.rd_value is not null
and ( d.sys_record_id is null or (d.sys_record_id is not null and not( v.rd_value between (d.rd_value-0.001) and (d.rd_value+0.001) ) ) )

Note the modification of the 'rkey' field - this is to allow each row to be identified as a separate record.

D_INTERVAL_TEMPORAL_YORK

insert into yorkdb_20210503.dbo.dit2
(
ypdt_int_id
,york_int_id
,sys_record_id
,ormgp_add_sys_record_id
,ormgp_cur_sys_record_id
,rd_date
,rd_type_code
,rd_name_code
,rd_value
,ormgp_cur_rd_value
,unit_code
,rd_name_ouom
,rd_value_ouom
,rd_unit_ouom
,rkey
)
select
v.ypdt_int_id
,v.york_int_id
,v.sys_record_id
,v.ypdt_sys_record_id as ormgp_add_sys_record_id
,d.sys_record_id as ormgp_cur_sys_record_id
,v.rd_date
,v.rd_type_code
,v.rd_name_code
,v.rd_value
,d.rd_value as ormgp_cur_rd_value
,v.unit_code
,v.rd_name_ouom
,v.rd_value_ouom
,v.rd_unit_ouom
,( row_number() over (order by v.sys_record_id) ) + 9664584 as rkey
from 
yorkdb_20210503.dbo.v_tr_dityork as v
left outer join oak_20160831_master.dbo.d_interval_temporal_2 as d
on v.ypdt_int_id=d.int_id and v.rd_date=d.rd_date and v.rd_name_code=d.rd_name_code 
where 
v.rd_value is not null
and ( d.sys_record_id is null or (d.sys_record_id is not null and not( v.rd_value between (d.rd_value-0.001) and (d.rd_value+0.001) ) ) )

And D_INTVL_TEMP2

insert into yordb_20210503.dbo.dit2
(
ypdt_int_id
,york_int_id
,sys_record_id
,ormgp_add_sys_record_id
,ormgp_cur_sys_record_id
,rd_date
,rd_type_code
,rd_name_code
,rd_value
,ormgp_cur_rd_value
,unit_code
,rd_name_ouom
,rd_value_ouom
,rd_unit_ouom
,rkey
)
select
v.ypdt_int_id
,v.york_int_id
,v.sys_record_id
,v.ypdt_sys_record_id as ormgp_add_sys_record_id
,d.sys_record_id as ormgp_cur_sys_record_id
,v.rd_date
,v.rd_type_code
,v.rd_name_code
,v.rd_value
,d.rd_value as ormgp_cur_rd_value
,v.unit_code
,v.rd_name_ouom
,v.rd_value_ouom
,v.rd_unit_ouom
,( row_number() over (order by v.sys_record_id) ) + 9664584 as rkey
from 
yorkdb_20210503.dbo.v_tr_ditvl2 as v
left outer join oak_20160831_master.dbo.d_interval_temporal_2 as d
on v.ypdt_int_id=d.int_id and v.rd_date=d.rd_date and v.rd_name_code=d.rd_name_code 
where 
v.rd_value is not null
and ( d.sys_record_id is null or (d.sys_record_id is not null and not( v.rd_value between (d.rd_value-0.001) and (d.rd_value+0.001) ) ) )

The D_INTERVAL_TEMPORAL_1A/_1B tables are created using INTO statements.

D_INTERVAL_TEMPORAL_1A

SELECT
ypdt_int_id,
york_int_id,
ypdt_sam_id,
sam_id,
sam_sample_name,
ypdt_sam_sample_name,
sam_sample_date,
sam_analysis_date,
sam_lab_sample_id,
ypdt_sam_lab_sample_id,
sam_lab_job_number,
ypdt_sam_lab_job_number,
sam_internal_id,
sam_sample_name_ouom,
sam_type_code,
ypdt_sam_type_code,
sam_sample_date_ouom,
sam_comment,
sam_data_file,
sys_time_stamp,
data_id,
rkey
into yorkdb_20210503.dbo.dit1a
FROM 
yorkdb_20210503.dbo.v_tr_dit1a
where 
ypdt_sam_id is null

D_INTERVAL_TEMPORAL_1B

SELECT
sam_id,
ypdt_sam_id,
rd_value_qualifier,
rd_value,
ypdt_rd_name_code,
ypdt_unit_code,
rd_mdl,
rd_rdl,
ypdt_rd_name_description,
rd_value_ouom,
ypdt_unit_description,
rd_mdl_ouom,
rd_rdl_ouom,
rd_comment,
sys_record_id,
ypdt_sys_record_id,
sys_time_stamp,
rkey
into yorkdb_20210503.dbo.dit1b
FROM 
yorkdb_20210503.dbo.v_tr_dit1b
where
ypdt_sam_id is null

The row counts for the 20171124 YKDB import were as follows:

D_INTERVAL_TEMPORAL_1A - 4865
D_INTERVAL_TEMPORAL_1B - 51119
D_INTERVAL_TEMPORAL_2 - 15871104 

The row counts for the 20181008 YKDB import were as follows:

D_INTERVAL_TEMPORAL_1A - 679
D_INTERVAL_TEMPORAL_1B - 8451
D_INTERVAL_TEMPORAL_2 (update) - 3891217
D_INTERVAL_TEMPORAL_2 (new) - 7435230

These tables can now be processed for new identifiers and then incorporated in the MADB.

G.28 Updating elevations in D_* tables

Tables

    - D_BOREHOLE
    - D_BOREHOLE_CONSTRUCTION
    - D_GEOLOGY_FORMATION
    - D_GEOLOGY_LAYER
    - D_PICK
    - D_INTERVAL_REFERENCE_ELEVATION
    - D_INTERVAL_MONITOR
    - D_INTERVAL_SOIL
    - D_INTERVAL_TEMPORAL_2

Views

    - V_SYS_CHK_CORR_ELEV_DBOR
    - V_SYS_CHK_CORR_ELEV_DBC
    - V_SYS_CHK_CORR_ELEV_DGF
    - V_SYS_CHK_CORR_ELEV_DGL
    - V_SYS_CHK_CORR_ELEV_DPICK
    - V_SYS_CHK_CORR_ELEV_DIRE
    - V_SYS_CHK_CORR_ELEV_DIM
    - V_SYS_CHK_CORR_ELEV_DIS
    - V_SYS_CHK_CORR_ELEV_D2

Estimated Recurrence Time: Weekly (or at time of elevation update)

For correction of elevations the value of BH_GND_ELEV in D_BOREHOLE must be populated and correct (a separate process; refer to Appendix G.4 for details).

Each of the views, above, are run in turn.

V_SYS_CHK_CORR_ELEV_DBOR (D_BOREHOLE)

Calculates NEW_BH_BOTTOM_ELEV and NEW_BH_BOTTOM_DEPTH; returns a record if the former does not match the original BH_BOTTOM_ELEV.

V_SYS_CHK_CORR_ELEV_DBC (D_BOREHOLE_CONSTRUCTION)

Calculates NEW_CON_TOP_ELEV and NEW_CON_BOT_ELEV; returns a record if either does not match the original (and respective) CON_TOP_ELEV or CON_BOT_ELEV.

V_SYS_CHK_CORR_ELEV_DGF (D_GEOLOGY_FORMATION)

Calculates NEW_FEATURE_TOP_ELEV and NEW_FEATURE_BOT_ELEV; returns a record if either does not match the original (and respective) FEATURE_TOP_ELEV or FEATURE_BOT_ELEV.

V_SYS_CHK_CORR_ELEV_DGL (D_GEOLOGY_LAYER)

Calculates NEW_GEOL_TOP_ELEV and NEW_GEOL_BOT_ELEV; returns a record if either does not match the original (and respective) GEOL_TOP_ELEV or GEOL_BOT_ELEV.

V_SYS_CHK_CORR_ELEV_DPICK (D_PICK)

The difference between the ground elevation in D_PICK (GND_ELEV) and D_BOREHOLE (BH_GND_ELEV) is compared and stored in BE_PE_CMP_M if they do not match.  The recalculated pick top elevation is stored in BE_NEW_TOP_ELEV.  If BE_PE_CMP_M is not null then the ground elevation has changed and the pick should be updated.  Note that allow rows are returned (this is different than most of the other views here).

V_SYS_CHK_CORR_ELEV_DIRE (D_INTERVAL_REFERENCE_ELEVATION)

This uses V_SYS_INT_REF_ELEV_RANGE as a source which calculates a new reference elevation REF_ELEV_BE_CMP (based upon BH_GND_ELEV and REF_STICK_UP).  This value is compared against the current REF_ELEV and stored in BE_RE_CMP_M - if this value is not null then the ground elevation has changed and the record should be updated.  Only records matching this case will be returned by the calling view.

V_SYS_CHK_CORR_ELEV_DIM (D_INTERVAL_MONITOR)

Calculates NEW_MON_TOP_ELEV, NEW_MON_BOT_ELEV, NEW_MON_TOP_DEPTH_M and NEW_MON_BOT_DEPTH_M; returns a record if either of the calculated elevations do not match (respectively) MON_TOP_ELEV or MON_BOT_ELEV.

V_SYS_CHK_CORR_ELEV_DIS (D_INTERVAL_SOIL)

Calculates NEW_SOIL_TOP_ELEV, NEW_SOIL_BOT_ELEV, NEW_SOIL_TOP_M and NEW_SOIL_BOT_M; returns a record if either of the calculated elevations do not match (respectively) SOIL_TOP_ELEV or SOIL_BOT_ELEV.

V_SYS_CHK_CORR_ELEV_D2 (D_INTERVAL_TEMPORAL_2)

Calculates NEW_RD_VALUE for any record that has a UNIT_CODE of '6' (i.e. 'masl'); returns a record if this does not match the current RD_VALUE

G.29 Update MOE BORE_HOLE_ID (D_LOCATION_ALIAS)

Tables

    - D_LOCATION_ALIAS
    - tblBore_Hole (MOE WWDB; MOEDB)

Views

    - V_SYS_MOE_LOCATIONS

Estimated Recurrence Time: After MOE WWDB import.

Upon import of the latest version of the MOE WWDB (refer to Section G.10), a check should be made of any new mapping between a BORE_HOLE_ID (in the MOE database; MOEDB) and a LOC_ID (in the ORMGP database; ORMGPDB).  Note that this will only apply in the case of a 1:1 relationship a single WELL_ID matching a single BORE_HOLE_ID in the MOEDB; in the ORMGPDB, a single WELL_ID maps to a single LOC_ID.

This is first tested using the following script

select
v.loc_id
,t3.well_id
,t3.bore_hole_id
,v.moe_bore_hole_id
--count(*) as rcount
from 
(
select
cast(t2.well_id as int) as well_id
,b2.bore_hole_id
from 
(
select
t.well_id
from 
(
select
b.well_id
,count(*) as bhi_num
from 
moe_20190509.dbo.tblbore_hole as b
group by
well_id
) as t
where 
t.bhi_num= 1
) as t2
inner join moe_20190509.dbo.tblbore_hole as b2
on t2.well_id=b2.well_id
) as t3
inner join oak_20160831_master.dbo.v_sys_moe_locations as v
on t3.well_id=v.moe_well_id
where 
v.moe_bore_hole_id is null

Any NULL values occurring in the MOE_BORE_HOLE_ID field (or any rows returned) indicate that the BORE_HOLE_ID needs to be incorporated in the D_LOCATION_ALIAS table, as follows

insert into d_location_alias
(
loc_id, loc_name_alias, loc_alias_type_code, data_id, sys_temp1, sys_temp2
)
select
v.loc_id
,cast(t3.bore_hole_id as varchar(255)) as loc_name_alias
,3 as loc_alias_type_code
,521 as data_id
,'20190530a' as sys_temp1
,20190530 as sys_temp2
from 
(
select
cast(t2.well_id as int) as well_id
,b2.bore_hole_id
from 
(
select
t.well_id
from 
(
select
b.well_id
,count(*) as bhi_num
from 
moe_20190509.dbo.tblbore_hole as b
group by
well_id
) as t
where 
t.bhi_num= 1
) as t2
inner join moe_20190509.dbo.tblbore_hole as b2
on t2.well_id=b2.well_id
) as t3
inner join oak_20160831_master.dbo.v_sys_moe_locations as v
on t3.well_id=v.moe_well_id
where 
v.moe_bore_hole_id is null

This process should be undertaken before examining locations for new data from the latest MOEDB.  Note the inclusion of the DATA_ID (which should correspond to the MOEDB under examination) and SYS_TEMP1/SYS_TEMP2 (making them available for any subsequent checks).

G.30 Update Locations from MOE WWDB

Tables (OAK_20160831_MASTER compatible)
    - D_BOREHOLE
    - D_BOREHOLE_CONSTRUCTION
    - D_DATA_SOURCE
    - D_GEOLOGY_FEATURE
    - D_GEOLOGY_LAYER
    - D_INTERVAL
    - D_INTERVAL_MONITOR
    - D_INTERVAL_REF_ELEV
    - D_INTERVAL_TEMPORAL_2
    - D_LOCATION
    - D_LOCATION_ALIAS
    - D_LOCATION_ELEV
    - D_LOCATION_PURPOSE
    - D_LOCATION_QA
    - D_PUMPTEST
    - D_PUMPTEST_STEP

Tables (MOE Water Well Database, MOE_20190509)
    - TblBore_Hole
    - TblCasing
    - TblFormation
    - TblHole
    - TblMethod_Construction
    - TblPipe
    - TblPlug
    - TblPump_Test
    - TblPump_Test_Detail
    - TblScreen
    - TblWater
    - TblWWR

Estimated Recurrence Time: After MOE WWDB import.

After the MOE WWDB (MOEDB) has been imported, a check should be made as to whether any locations currently present in the master database (ORMGPDB) have been updated in the MOEDB.  We'll determine this on a table-by-table basis.  Many of the methods and queries used herein are adapted from Section G.10.

G.30.1 D_GEOLOGY_LAYER

Here we are looking at those locations that do not have any records present in D_GEOLOGY_LAYER.  We cannot rely upon differences in record counts between this table and [tblFormation] (in the MOEDB) as geologic layer corrections are made in the ORMGPDB.  We will create a table to be used as a reference to those LOC_IDs for which we will extract information from [tblFormation].

select
t.*
,t2.rcount_moe
--count(*) as rcount
into moe_20190509.dbo.ORMGP_20190509_upd_DGL
from 
(
select
dbore.loc_id
,v.moe_well_id
,v.moe_bore_hole_id
,dgl.rcount
,dloc.loc_type_code
from 
oak_20160831_master.dbo.d_borehole as dbore
inner join oak_20160831_master.dbo.d_location as dloc
on dbore.loc_id=dloc.loc_id
inner join oak_20160831_master.dbo.d_location_qa as dlqa
on dbore.loc_id=dlqa.loc_id
inner join oak_20160831_master.dbo.v_sys_agency_ypdt as yc
on dbore.loc_id=yc.loc_id
left outer join 
(
select
loc_id
,count(*) as rcount
from 
oak_20160831_master.dbo.d_geology_layer
group by 
loc_id
) as dgl
on dbore.loc_id=dgl.loc_id
inner join oak_20160831_master.dbo.v_sys_moe_locations as v
on dbore.loc_id=v.loc_id
where 
dgl.rcount is null
and dloc.loc_type_code=1
and dlqa.qa_coord_confidence_code<>117
) as t
inner join 
(
select
m.bore_hole_id
,count(*) as rcount_moe
from 
moe_20190509.dbo.tblformation as m
where 
m.mat1 is not null
and cast(m.mat1 as int)<>0
group by
bore_hole_id
) as t2
on t.moe_bore_hole_id=t2.bore_hole_id

Script: G_30_01_01_DGL_BORE_HOLE_ID.sql

Now that we have a list of locations which require updating, make sure that their material codes in the MOEDB are not specified as 'Other' (i.e. '27'); make them 'Unknown' (i.e. '0') instead.  This needs to be accomplished for each of the three material fields, only the first is shown here.

update MOE_20190509.dbo.TblFormation
set
MAT1=0
from 
MOE_20190509.dbo.TblFormation as mf
inner join ORMGP_20190509_upd_DGL as od
on mf.bore_hole_id=od.moe_bore_hole_id
where 
mf.MAT1=27

Script: G_30_01_02_DGL_MATS.sql

Check that the depth units are one of 'ft' or 'm' - modify others as necessary (not shown).

select 
od.LOC_ID
,mf.*
from 
MOE_20190509.dbo.TblFormation as mf
inner join ORMGP_20190509_upd_DGL as od
on mf.bore_hole_id=od.moe_bore_hole_id
where 
not(mf.FORMATION_END_DEPTH_UOM in ('ft','m'))
order by
od.loc_id,mf.formation_top_depth

Script: G_30_01_03_DGL_UNITS.sql

We can now create the temporary file containing the new MOEDB information, formated to match D_GEOLOGY_LAYER.  Note that we are including values for DATA_ID, SYS_TEMP1 and SYS_TEMP2 for subsequent tracking purposes.

select
od.LOC_ID
,cast( null as int ) as GEOL_ID
,cast( case
 when moef.COLOR is null or moef.COLOR=0 then null 
 else moef.COLOR 
end as int) as [GEOL_MAT_COLOUR_CODE]
,case
when moef.FORMATION_END_DEPTH_UOM='m' then ( dbore.bh_gnd_elev - moef.formation_top_depth )
else ( dbore.bh_gnd_elev - ( moef.formation_top_depth * 0.3048 ) ) 
end as GEOL_TOP_ELEV
,case
when moef.FORMATION_END_DEPTH_UOM='m' then ( dbore.bh_gnd_elev - moef.formation_end_depth ) 
else ( dbore.bh_gnd_elev - ( moef.formation_end_depth * 0.3048 ) )
end as GEOL_BOT_ELEV
,moef.FORMATION_TOP_DEPTH as GEOL_TOP_OUOM 
,moef.FORMATION_END_DEPTH as GEOL_BOT_OUOM
,cast(moef.FORMATION_END_DEPTH_UOM as varchar(20)) as GEOL_UNIT_OUOM
,moef.LAYER as GEOL_MOE_LAYER
,cast( case 
 -- check if all mat fields are null
 when moef.MAT1 is null and moef.MAT2 is null and moef.MAT3 is null then 0
 -- if mat1 is null but mat2 is not, make mat1=mat2
 when moef.MAT1 is null and moef.MAT2 is not null then moef.MAT2 
 -- if mat1 and mat2 is null but mat3 is not, make mat1=mat3
 when moef.MAT1 is null and moef.MAT2 is null and moef.MAT3 is not null then moef.MAT3 
 else moef.MAT1 
end as int) as GEOL_MAT1_CODE
,cast( case 
 -- if all mat fields are null, leave mat2 as is
 -- if mat1 is null, mat2 has been moved to mat1, return null
 -- we won't move mat3 to mat2
 when moef.MAT1 is null and moef.MAT2 is not null then null 
 else moef.MAT2 
end as int) as GEOL_MAT2_CODE
,cast( case 
 -- if mat1 and mat2 is null but mat3 is not, make mat1=mat3
 when moef.MAT1 is null and moef.MAT2 is null and moef.MAT3 is not null then null 
 else moef.MAT3 
end as int) as GEOL_MAT3_CODE
-- include some comments if we've messed about with the mat codes
,cast( case 
 when moef.MAT1 is null and moef.MAT2 is null and moef.MAT3 is null then     'No material, assigned unknown'
 when moef.MAT1 is null and moef.MAT2 is not null then                       'No mat1, assigned mat2 to mat1'
 when moef.MAT1 is null and moef.MAT2 is null and moef.MAT3 is not null then 'No mat1 or mat2, assigned mat3 to mat1'
 else null 
end as varchar(255)) as GEOL_COMMENT
,cast( 521 as int ) as DATA_ID
,'20190531a' as SYS_TEMP1
,20190531 as SYS_TEMP2
,row_number() over (order by od.loc_id) as rkey
into O_D_GEOLOGY_LAYER
from 
ORMGP_20190509_upd_DGL as od
inner join MOE_20190509.dbo.TblFormation as moef
on od.moe_bore_hole_id=moef.bore_hole_id
inner join oak_20160831_master.dbo.d_borehole as dbore
on od.loc_id=dbore.loc_id

We will now create the new GEOL_IDs necessary for import.

update moe_20190509.dbo.o_d_geology_layer
set
geol_id=t2.geol_id
from 
moe_20190509.dbo.o_d_geology_layer as od
inner join
(
select
t.geol_id
,row_number() over (order by t.geol_id) as rkey
from 
(
select
top 5000
v.new_id as geol_id
from 
oak_20160831_master.dbo.v_sys_random_id_bulk_001 as v
where 
v.new_id not in
( select geol_id from oak_20160831_master.dbo.d_geology_layer )
) as t
) as t2
on od.rkey=t2.rkey

And, finally, insert the new MOEDB information.

insert into oak_20160831_master.dbo.d_geology_layer
(
[LOC_ID], 
[GEOL_ID], 
[GEOL_MAT_COLOUR_CODE], 
[GEOL_TOP_ELEV], 
[GEOL_BOT_ELEV], 
[GEOL_TOP_OUOM], 
[GEOL_BOT_OUOM], 
[GEOL_UNIT_OUOM], 
[GEOL_MOE_LAYER], 
[GEOL_MAT1_CODE], 
[GEOL_MAT2_CODE], 
[GEOL_MAT3_CODE], 
[GEOL_COMMENT], 
[DATA_ID], 
[SYS_TEMP1], 
[SYS_TEMP2]
)
select
[LOC_ID], 
[GEOL_ID], 
[GEOL_MAT_COLOUR_CODE], 
[GEOL_TOP_ELEV], 
[GEOL_BOT_ELEV], 
[GEOL_TOP_OUOM], 
[GEOL_BOT_OUOM], 
[GEOL_UNIT_OUOM], 
[GEOL_MOE_LAYER], 
[GEOL_MAT1_CODE], 
[GEOL_MAT2_CODE], 
[GEOL_MAT3_CODE], 
[GEOL_COMMENT], 
[DATA_ID], 
[SYS_TEMP1], 
[SYS_TEMP2]
from 
moe_20190509.dbo.o_d_geology_layer

Script: G_30_01_04_DGL_ADD.sql

G.30.2 D_GEOLOGY_FEATURE

Here we are looking at those locations that do not have any records present in D_GEOLOGY_FEATURE.  Similar to the process for D_GEOLOGY_LAYER, we shouldn't rely upon differences in record counts between the MOEDB and ORMDB.  We'll (again) create a table to be used as a reference to those LOC_IDs for which we will extract information.

select
t.*
,t2.rcount_moe
--count(*) as rcount
into moe_20190509_final.dbo.ORMGP_20190509_upd_DGF
from 
(
select
dbore.loc_id
,v.moe_well_id
,v.moe_bore_hole_id
,dgl.rcount
from 
oak_20160831_master.dbo.d_borehole as dbore
inner join oak_20160831_master.dbo.d_location as dloc
on dbore.loc_id=dloc.loc_id
inner join oak_20160831_master.dbo.d_location_qa as dlqa
on dbore.loc_id=dlqa.loc_id
inner join oak_20160831_master.dbo.v_sys_agency_ypdt as yc
on dbore.loc_id=yc.loc_id
left outer join 
(
select
loc_id
,count(*) as rcount
from 
oak_20160831_master.dbo.d_geology_feature
group by 
loc_id
) as dgl
on dbore.loc_id=dgl.loc_id
inner join oak_20160831_master.dbo.v_sys_moe_locations as v
on dbore.loc_id=v.loc_id
where 
dgl.rcount is null
and dloc.loc_type_code=1
and dlqa.qa_coord_confidence_code<>117
and v.moe_bore_hole_id is not null
) as t
inner join 
(
select
moep.bore_hole_id
,count(*) as rcount_moe
from 
MOE_20190509.dbo.TblPipe as moep
inner join MOE_20190509.[dbo].[TblWater] as moew
on moep.PIPE_ID=moew.PIPE_ID
group by
moep.bore_hole_id
) as t2
on t.moe_bore_hole_id=t2.bore_hole_id

Script: G_30_02_01_DGF_BORE_HOLE_ID.sql

We can then create the base table that will be used for import into the ORMDB.

select
y.LOC_ID
,cast(null as int) as FEATURE_ID
,case
when moew.kind is null or moew.kind=0 then null -- not specified
else moew.kind                                  -- matches YC codes
end 
as [FEATURE_CODE]
,'Water Found' as [FEATURE_DESCRIPTION]
,moew.WATER_FOUND_DEPTH as [FEATURE_TOP_OUOM]
,moew.WATER_FOUND_DEPTH_UOM as [FEATURE_UNIT_OUOM]
,cast(521 as int) as DATA_ID
,ROW_NUMBER() over (order by y.LOC_ID) as rkey
into MOE_20190509.dbo.O_D_GEOLOGY_FEATURE
from 
MOE_20190509.dbo.ORMGP_20190509_upd_DGF as y
inner join MOE_20190509.dbo.TblPipe as moep
on y.moe_bore_hole_id=moep.Bore_Hole_ID
inner join MOE_20190509.[dbo].[TblWater] as moew
on moep.PIPE_ID=moew.PIPE_ID

Update the FEATURE_ID field.

update moe_20190509.dbo.o_d_geology_feature
set
feature_id=t2.feature_id
from 
moe_20190509.dbo.o_d_geology_feature as od
inner join
(
select
t.feature_id
,row_number() over (order by t.feature_id) as rkey
from 
(
select
top 10000
v.new_id as feature_id
from 
oak_20160831_master.dbo.v_sys_random_id_bulk_001 as v
where 
v.new_id not in
( select feature_id from oak_20160831_master.dbo.d_geology_feature )
) as t
) as t2
on od.rkey=t2.rkey

And, finally, insert the records into D_GEOLOGY_FEATURE.

insert into oak_20160831_master.dbo.d_geology_feature
(
[LOC_ID], 
[FEATURE_ID], 
[FEATURE_CODE], 
[FEATURE_DESCRIPTION], 
[FEATURE_TOP_OUOM], 
[FEATURE_UNIT_OUOM], 
[DATA_ID],
SYS_TEMP1,
SYS_TEMP2
)
select
[LOC_ID], 
[FEATURE_ID], 
[FEATURE_CODE], 
[FEATURE_DESCRIPTION], 
[FEATURE_TOP_OUOM], 
[FEATURE_UNIT_OUOM], 
[DATA_ID],
cast( '20190509a' as varchar(255) ) as SYS_TEMP1,
cast( 20190509 as int ) as SYS_TEMP2
from 
moe_20190509.dbo.o_d_geology_feature

Script: G_30_02_02_DGF_ADD.sql

G.30.3 D_BOREHOLE_CONSTRUCTION

We will now examine those MOE locations present in the ORMDB that do not have any borehole construction details.  Determine these locations and create a temporary reference table (for speed/access purposes).  Index the resultant table-fields (i.e. the identifier fields) to enhance access.  Note that there may be instances of multiple BORE_HOLE_IDs present for a single LOC_ID.  These seem to be decommissioned or alteration records.  Refer also to Section G.10.10 for additional details.

select
dbore.loc_id
,v.moe_bore_hole_id
--into moe_20190509_final.dbo.ORMGP_20190509_base_DBHCONS
from 
oak_20160831_master.dbo.d_borehole as dbore
inner join oak_20160831_master.dbo.d_location as dloc
on dbore.loc_id=dloc.loc_id
inner join oak_20160831_master.dbo.d_location_qa as dlqa
on dbore.loc_id=dlqa.loc_id
inner join oak_20160831_master.dbo.v_sys_agency_ypdt as yc
on dbore.loc_id=yc.loc_id
left outer join 
(
select
loc_id
,count(*) as rcount
from 
oak_20160831_master.dbo.d_borehole_construction as dbc
inner join oak_20160831_master.dbo.d_borehole as dbore
on dbc.bh_id=dbore.bh_id
group by 
dbore.loc_id
) as d
on dbore.loc_id=d.loc_id
inner join oak_20160831_master.dbo.v_sys_moe_locations as v
on dbore.loc_id=v.loc_id
where 
d.rcount is null
and dloc.loc_type_code=1
and dlqa.qa_coord_confidence_code<>117
and v.moe_bore_hole_id is not null
group by
dbore.loc_id,v.moe_bore_hole_id

Assemble any casing information for these locations.

select
-- note that we're using BORE_HOLE_ID as a temporary BH_ID
y.LOC_ID
,y.moe_BORE_HOLE_ID as BH_ID
,case
when moec.MATERIAL is null then 10      -- unknown
when moec.MATERIAL = 1     then 21      -- steel casing
when moec.MATERIAL = 2     then 16      -- galvanized
when moec.MATERIAL = 3     then 23      -- concrete
when moec.MATERIAL = 4     then 24      -- open hole
when moec.MATERIAL = 5     then 25      -- plastic
when moec.MATERIAL = 6     then 32      -- fibreglass
end 
as [CON_SUBTYPE_CODE]
,moec.DEPTH_FROM as [CON_TOP_OUOM]
,moec.DEPTH_TO as [CON_BOT_OUOM]
,moec.CASING_DEPTH_UOM as [CON_UNIT_OUOM]
,moec.CASING_DIAMETER as [CON_DIAMETER_OUOM]
,moec.CASING_DIAMETER_UOM as [CON_DIAMETER_UNIT_OUOM]
,convert(varchar(255),null) as CON_COMMENT
--into MOE_20190509_final.dbo.ORMGP_20190509_upd_DBHCONS
from 
MOE_20190509_final.dbo.ORMGP_20190509_base_DBHCONS as y
inner join MOE_20190509_final.dbo.TblPipe as moep
on y.moe_BORE_HOLE_ID=moep.Bore_Hole_ID
inner join MOE_20190509_final.dbo.TblCasing as moec
on moep.PIPE_ID=moec.PIPE_ID
where
not
(
moec.DEPTH_TO is null 
and moec.CASING_DEPTH_UOM is null 
and moec.CASING_DIAMETER is null 
and moec.CASING_DIAMETER_UOM is null
)

Add any plug information.

insert into MOE_20190509_final.dbo.ORMGP_20190509_upd_DBHCONS
(LOC_ID,BH_ID,CON_SUBTYPE_CODE,CON_TOP_OUOM,CON_BOT_OUOM,CON_UNIT_OUOM)
select 
-- note that we're using BORE_HOLE_ID as a temporary BH_ID
y.LOC_ID
,y.moe_BORE_HOLE_ID as BH_ID
,31 as CON_SUBTYPE_CODE
,moep.PLUG_FROM as [CON_TOP_OUOM]
,moep.PLUG_TO   as [CON_BOT_OUOM]
,moep.PLUG_DEPTH_UOM as [CON_UNIT_OUOM]
from 
MOE_20190509_final.dbo.ORMGP_20190509_base_DBHCONS as y
inner join MOE_20190509_final.dbo.TblPlug as moep
on y.moe_BORE_HOLE_ID=moep.BORE_HOLE_ID
where 
not 
(
moep.PLUG_FROM is null 
and moep.PLUG_TO is null 
and moep.PLUG_DEPTH_UOM is null 
)

Swap the top and bottom depths if the former is larger than the second (not shown).  Create the final, formatted table including the updated DATA_ID and a set of tags for SYS_TEMP1 and SYS_TEMP2 (for reference).  Pull the actual BH_ID for the location from the ORMDB.  Note that we're introducing a counter for later assignment of random identifiers.

SELECT 
d.[BH_ID]
,[CON_SUBTYPE_CODE]
,[CON_TOP_OUOM]
,[CON_BOT_OUOM]
,[CON_UNIT_OUOM]
,[CON_DIAMETER_OUOM]
,[CON_DIAMETER_UNIT_OUOM]
,[CON_COMMENT]
,cast( 521 as int ) as DATA_ID
,cast(null as int) as SYS_RECORD_ID
,cast( '20190509a' as varchar(255) ) as SYS_TEMP1
,cast( 20190509 as int ) as SYS_TEMP2
,ROW_NUMBER() over (order by y.BH_ID) as rkey
,y.bh_id as moe_bore_hole_id
--into moe_20190509_final.dbo.O_D_BOREHOLE_CONSTRUCTION
FROM 
MOE_20190509_final.[dbo].ORMGP_20190509_upd_DBHCONS as y
inner join oak_20160831_master.dbo.d_borehole as d
on y.loc_id=d.loc_id

Script: G_30_03_01_DBHCONS.sql

Update the SYS_RECORD_ID and insert the final information into D_BOREHOLE_CONSTRUCTION in the ORMDB (not shown).

G.30.4 Depths

In order to process the screen information (as found in the next section, G.30.5) for some of the screen types, we'll need to determine the depth of the borehole in question.  Similar to the methodology in Section G.10, we'll look at tables for each of: formation; water found; borehole construction; MOE assigned.  From these, we'll determine the maximum depth.

First, we'll assemble all those locations in the ORMDB that currently have no depth associated with them as found in D_BOREHOLE.  This is irregardless of whether they have updated depths in the MOEDB.

select
dbore.loc_id
,v.moe_bore_hole_id
,cast(null as float) as fm_max_depth_m
,cast(null as float) as dgf_max_depth_m
,cast(null as float) as casing_max_depth_m
,cast(null as float) as dbc_max_depth_m
,cast(null as float) as moe_max_depth_m
,cast(null as float) as max_depth_m
into moe_20200721.dbo.ORMGP_20200721_upd_DEPTH
from 
oak_20160831_master.dbo.d_borehole as dbore
inner join oak_20160831_master.dbo.d_location as dloc
on dbore.loc_id=dloc.loc_id
inner join oak_20160831_master.dbo.d_location_qa as dlqa
on dbore.loc_id=dlqa.loc_id
inner join oak_20160831_master.dbo.v_sys_agency_ypdt as yc
on dbore.loc_id=yc.loc_id
inner join oak_20160831_master.dbo.v_sys_moe_locations as v
on dbore.loc_id=v.loc_id
where 
dbore.bh_bottom_ouom is null
and dloc.loc_type_code=1
and dlqa.qa_coord_confidence_code<>117
and v.moe_bore_hole_id is not null
group by
dbore.loc_id,v.moe_bore_hole_id

Note that we're creating a series of NULL fields which we will subsequently populate.  Now, determine the maximum formation depth.

update moe_20200721.dbo.ormgp_20200721_upd_depth
set
fm_max_depth_m= t2.fm_max_depth_m
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm2
inner join
(
select
t.moe_bore_hole_id
,max(t.fm_end_depth) as fm_max_depth_m
from
(
select
orm.moe_bore_hole_id
,case
when moe.[FORMATION_END_DEPTH_UOM]='ft' then moe.[FORMATION_END_DEPTH]*0.3048
else moe.[FORMATION_END_DEPTH]
end as fm_end_depth
from 
moe_20200721.dbo.ORMGP_20200721_upd_DEPTH as orm
inner join moe_20200721.dbo.tblformation as moe
on orm.moe_bore_hole_id=moe.bore_hole_id
) as t
group by 
t.moe_bore_hole_id
) as t2
on orm2.moe_bore_hole_id=t2.moe_bore_hole_id

Check the casing for inverted top- and bottom-depths.

update moe_20200721.dbo.tblcasing
set
depth_from=depth_to
,depth_to=depth_from
where 
depth_from>depth_to

Then process the various tables for construction details/depths.  

update moe_20200721.dbo.ormgp_20200721_upd_depth
set
dbc_max_depth_m= t2.dbc_max_depth_m
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join
(
select
t.moe_bore_hole_id
,max(t.dbc_depth) as dbc_max_depth_m
from 
(
select
orm.moe_bore_hole_id
,case
when mcase.casing_depth_uom = 'ft' then mcase.depth_to * 0.3048
else mcase.depth_to
end as dbc_depth
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join moe_20200721.dbo.tblbore_hole as mbore
on orm.moe_bore_hole_id=mbore.bore_hole_id
inner join moe_20200721.dbo.tblcasing as mcase
on mbore.well_id=mcase.well_id
union all
select
orm.moe_bore_hole_id
,case
when mplug.plug_depth_uom = 'ft' then mplug.plug_to * 0.3048
else mplug.plug_to
end as dbc_depth
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join moe_20200721.dbo.tblplug as mplug
on orm.moe_bore_hole_id=mplug.bore_hole_id
union all
select
orm.moe_bore_hole_id
,case
when mscr.scrn_depth_uom = 'ft' then mscr.scrn_end_depth * 0.3048
else mscr.scrn_end_depth
end as dbc_depth
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join moe_20200721.dbo.tblbore_hole as mbore
on orm.moe_bore_hole_id=mbore.bore_hole_id
inner join moe_20200721.dbo.tblscreen as mscr
on mbore.well_id=mscr.well_id
union all
select
orm.moe_bore_hole_id
,case
when mpump.levels_uom = 'ft' then mpump.recom_depth * 0.3048
else mpump.recom_depth
end as dbc_depth
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join moe_20200721.dbo.tblbore_hole as mbore
on orm.moe_bore_hole_id=mbore.bore_hole_id
inner join moe_20200721.dbo.tblpump_test as mpump
on mbore.well_id=mpump.well_id
) as t
group by
t.moe_bore_hole_id
) as t2
on orm.moe_bore_hole_id=t2.moe_bore_hole_id

We'll repeat part of this query in order to process the casing depths separately.

update moe_20200721.dbo.ormgp_20200721_upd_depth
set
casing_max_depth_m= t2.casing_max_depth_m
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join
(
select
t.moe_bore_hole_id
,max(t.dbc_depth) as casing_max_depth_m
from 
(
select
orm.moe_bore_hole_id
,case
when mcase.casing_depth_uom = 'ft' then mcase.depth_to * 0.3048
else mcase.depth_to
end as dbc_depth
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join moe_20200721.dbo.tblbore_hole as mbore
on orm.moe_bore_hole_id=mbore.bore_hole_id
inner join moe_20200721.dbo.tblcasing as mcase
on mbore.well_id=mcase.well_id
) as t
group by 
t.moe_bore_hole_id
) as t2
on orm.moe_bore_hole_id=t2.moe_bore_hole_id

Populate the geology features (i.e. water found) depths.

update moe_20200721.dbo.ormgp_20200721_upd_depth
set
dgf_max_depth_m= t2.dgf_max_depth_m
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join
(
select
t.moe_bore_hole_id
,max(t.dgf_depth) as dgf_max_depth_m
from 
(
select
orm.moe_bore_hole_id
,case
when mwater.water_found_depth_uom = 'ft' then mwater.water_found_depth * 0.3048
else mwater.water_found_depth
end as dgf_depth
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join moe_20200721.dbo.tblbore_hole as mbore
on orm.moe_bore_hole_id=mbore.bore_hole_id
inner join moe_20200721.dbo.tblwater as mwater
on mbore.well_id=mwater.well_id
) as t
group by
t.moe_bore_hole_id
) as t2
on orm.moe_bore_hole_id=t2.moe_bore_hole_id

And then, finally, the maximum depth as specified by the MOE.

update moe_20190509_final.dbo.ormgp_20190509_upd_depth
set
moe_max_depth_m= t2.moe_max_depth_m
from 
moe_20190509_final.dbo.ormgp_20190509_upd_depth as orm
inner join
(
select
t.moe_bore_hole_id
,max(t.moe_depth) as moe_max_depth_m
from 
(
select
orm.moe_bore_hole_id
,case
when mhole.hole_depth_uom = 'ft' then mhole.depth_to * 0.3048
else mhole.depth_to
end as moe_depth
from 
moe_20190509_final.dbo.ormgp_20190509_upd_depth as orm
inner join moe_20190509_final.dbo.tblhole as mhole
on orm.moe_bore_hole_id=mhole.bore_hole_id
) as t
group by
t.moe_bore_hole_id
) as t2
on orm.moe_bore_hole_id=t2.moe_bore_hole_id

We can now determine the maximum depth based upon the values of these four fields.

update moe_20200721.dbo.ormgp_20200721_upd_depth
set
max_depth_m= t.max_depth_m
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
inner join
(
select
orm.moe_bore_hole_id
,(
select max(v) from 
(
values (fm_max_depth_m),(dgf_max_depth_m),(dbc_max_depth_m),(moe_max_depth_m)
) as value(v)
) as max_depth_m
from 
moe_20200721.dbo.ormgp_20200721_upd_depth as orm
) as t
on orm.moe_bore_hole_id=t.moe_bore_hole_id

Script: G_30_04_01_DEPTHS.sql

This can now be used as a reference (value) in the following section.

G.30.5 D_INTERVAL and Associated

We will now examine those MOE locations present in the ORMDB that do not currently have screens identified.  Similar to Section G.10, the methodology will be adapted based upon the screen type (e.g. reported, open hole, etc...) as each of these require slightly differing steps.

We'll determine those locations already present in the ORMDB and create a temporary table - this is for speed purposes.  The alternative, on-the-fly analysis, takes a significant time.  Note that the resulting table will subsequently be indexed by hand (i.e. the identifier fields), again for speed purposes.  We're including locations/screens that are already present in the ORMDB D_INTERVAL table which have a screen type of 'Screen Information Omitted' (INT_TYPE_CODE 28; these were imported from an earlier MOEDB but did not have screen information at that time).  A non-null INT_ID identifies these locations.

select
t.*
,dint.int_id
into moe_20200721.dbo.ORMGP_20200721_base_DINT
from 
(
select
dbore.loc_id
,v.moe_bore_hole_id
from 
oak_20160831_master.dbo.d_borehole as dbore
inner join oak_20160831_master.dbo.d_location as dloc
on dbore.loc_id=dloc.loc_id
inner join oak_20160831_master.dbo.d_location_qa as dlqa
on dbore.loc_id=dlqa.loc_id
inner join oak_20160831_master.dbo.v_sys_agency_ypdt as yc
on dbore.loc_id=yc.loc_id
inner join oak_20160831_master.dbo.v_sys_moe_locations as v
on dbore.loc_id=v.loc_id
left outer join oak_20160831_master.dbo.d_interval as dint
on dbore.loc_id=dint.loc_id
where 
(dint.int_id is null or dint.int_type_code=28)
and dloc.loc_type_code=1
and dlqa.qa_coord_confidence_code<>117
and v.moe_bore_hole_id is not null
group by
dbore.loc_id,v.moe_bore_hole_id
) as t
left outer join oak_20160831_master.dbo.d_interval as dint
on t.loc_id=dint.loc_id

Now that we have a listing of the locations and their associated BORE_HOLE_ID, determine which of these actually has a reported screen.  We'll create the initial compatible table from which we'll generate D_INTERVAL and D_INTERVAL_MONITOR.

select 
d.LOC_ID
,d.INT_ID
,d.moe_bore_hole_id as TMP_INT_ID
,18 as tmp_INT_TYPE_CODE
,moeslot.CONV_YC_SLOT as MON_SCREEN_SLOT
,moes.SCRN_MATERIAL as MON_SCREEN_MATERIAL
,moes.SCRN_DIAMETER as MON_DIAMETER_OUOM
,moes.SCRN_DIAMETER_UOM as MON_DIAMETER_UNIT_OUOM
,moes.SCRN_TOP_DEPTH as MON_TOP_OUOM
,moes.SCRN_END_DEPTH as MON_BOT_OUOM
,moes.SCRN_DEPTH_UOM as MON_UNIT_OUOM
,cast(null as varchar(255)) as MON_COMMENT
into moe_20200721.dbo.ORMGP_20200721_upd_DINTMON
from 
moe_20200721.dbo.ORMGP_20200721_base_DINT as d
inner join 
MOE_20200721.dbo.TblPipe as moep
on d.moe_bore_hole_id=moep.Bore_Hole_ID
inner join
MOE_20200721.dbo.TblScreen as moes
on moep.PIPE_ID=moes.PIPE_ID
left outer join
MOE_20200721.dbo.YC_20200721_MOE_SLOT as moeslot
on moes.Slot=moeslot.MOE_SLOT
where 
moes.SCRN_TOP_DEPTH is not null 
or moes.SCRN_END_DEPTH is not null

Script: G_30_05_01_DINT_BORE_HOLE_ID.sql

We'll now check whether we have a non-reported screen, in this case an OPEN_HOLE (as declared in the MOEDB; bottom-of-casing to bottom-of-hole).  Add these to the temporary table ORMGP_20190509_upd_DINTMON.

insert into moe_20200721.dbo.ormgp_20200721_upd_dintmon
(
loc_id, tmp_int_id, tmp_int_type_code, mon_top_ouom, mon_bot_ouom, mon_unit_ouom, mon_comment
)
select
orm.LOC_ID
,orm.moe_bore_hole_id as tmp_INT_ID
,cast( 21 as int ) as tmp_INT_TYPE_CODE
,od.casing_max_depth_m as MON_TOP_OUOM
,od.max_depth_m as MON_BOT_OUOM
,cast( 'm' as varchar(50) ) as MON_UNIT_OUOM
,cast( 'open hole; bottom-of-casing to bottom-of-hole' as varchar(255) ) as MON_CMMENT
from 
moe_20200721.dbo.ormgp_20200721_base_dint as orm
inner join moe_20200721.dbo.ormgp_20200721_upd_depth as od
on orm.moe_bore_hole_id=od.moe_bore_hole_id
inner join moe_20200721.dbo.tblbore_hole as moebh
on orm.moe_bore_hole_id=moebh.bore_hole_id
where
moebh.OPEN_HOLE='Y'
and orm.moe_bore_hole_id not in
( select tmp_int_id from moe_20200721.dbo.ormgp_20200721_upd_dintmon )

If there are bedrock boreholes (and they haven't previously been assigned a screen), we can make the assumption that the screen is from the bottom-of-casing (penetrating to bedrock) to the bottom of the hole.  Add these (note that this query can take some time to complete).

insert into moe_20200721.dbo.ormgp_20200721_upd_dintmon
(
loc_id, int_id, tmp_INT_ID, tmp_int_type_code, mon_top_ouom, mon_bot_ouom, mon_unit_ouom, mon_comment
)
select
orm.LOC_ID
,orm.INT_ID
,orm.moe_bore_hole_id as tmp_INT_ID
,cast( 22 as int ) as tmp_INT_TYPE_CODE
,t2.geol_top_m as MON_TOP_OUOM
,od.max_depth_m as MON_BOT_OUOM
,'m' as MON_UNIT_OUOM
,cast( 'bedrock, no valid casing; open hole, top-of-bedrock to bottom-of-hole' as varchar(255) ) as MON_COMMENT
from 
moe_20200721.dbo.ormgp_20200721_base_dint as orm
inner join moe_20200721.dbo.ormgp_20200721_upd_depth as od
on orm.moe_bore_hole_id=od.moe_bore_hole_id
inner join
(
select
t.moe_bore_hole_id
,min(t.geol_top_m) as geol_top_m
,max(t.geol_bot_m) as geol_bot_m
from
(
select
orm.moe_bore_hole_id
,case
when mform.formation_end_depth_uom = 'ft' then mform.formation_top_depth * 0.3048
else mform.formation_top_depth
end as geol_top_m
,case
when mform.formation_end_depth_uom = 'ft' then mform.formation_end_depth * 0.3048
else mform.formation_end_depth
end as geol_bot_m
from 
moe_20200721.dbo.ormgp_20200721_base_dint as orm
inner join moe_20200721.dbo.tblformation as mform
on orm.moe_bore_hole_id=mform.bore_hole_id
inner join oak_20160831_master.dbo.r_geol_mat1_code as rgmc
on cast( mform.mat1 as int )=rgmc.geol_mat1_code
where 
rgmc.geol_mat1_rock=1
) as t
group by
t.moe_bore_hole_id
) as t2
on orm.moe_bore_hole_id=t2.moe_bore_hole_id
where 
orm.moe_bore_hole_id not in
( select tmp_int_id from moe_20200721.dbo.ormgp_20200721_upd_dintmon )

The remainder of the (possible) screens should be considered overburden boreholes.  As such, we'll assume a '0.3m' screen above the bottom-of-hole.  Only those with valid depths are considered.

insert into moe_20200721.dbo.ormgp_20200721_upd_dintmon
(
loc_id, int_id, tmp_int_id, tmp_int_type_code, mon_top_ouom, mon_bot_ouom, mon_unit_ouom, mon_comment
)
select 
orm.LOC_ID
,orm.INT_ID
,orm.moe_bore_hole_id as tmp_INT_ID
,19 as tmp_INT_TYPE_CODE
,( od.max_depth_m - 0.3 ) as MON_TOP_OUOM
,od.max_depth_m as MON_BOT_OUOM
,cast( 'm' as varchar(50) ) as MON_UNIT_OUOM
,cast( 'overburden; assumed screen, 0.3m above bottom-of-hole' as varchar(255) ) as MON_COMMENT
from 
moe_20200721.dbo.ormgp_20200721_base_dint as orm
inner join moe_20200721.dbo.ormgp_20200721_upd_depth as od
on orm.moe_bore_hole_id=od.moe_bore_hole_id
where 
od.max_depth_m is not null
and orm.moe_bore_hole_id not in
( select tmp_int_id from moe_20200721.dbo.ormgp_20200721_upd_dintmon )

Script: G_30_05_02_DINT_OTHER.sql

Make sure the ORMGP_20190509_upd_DINTMON has an indexed key (this may not be necessary - try running the 'select' statement before creating a new table to test the run time).  We can now create the D_INTERVAL and D_INTERVAL_MONITOR tables, the latter table should be assembled first (update the DATA_ID, SYS_TEMP1 and SYS_TEMP2 fields).

select 
dim.LOC_ID
,dim.tmp_INT_ID
,dim.tmp_INT_TYPE_CODE
,dim.INT_ID 
,dim.MON_SCREEN_SLOT
,cast(moeccm.DES as varchar(255)) as MON_SCREEN_MATERIAL
,dim.MON_DIAMETER_OUOM
,dim.MON_DIAMETER_UNIT_OUOM
,dim.MON_TOP_OUOM
,dim.MON_BOT_OUOM
,dim.MON_UNIT_OUOM
,dim.MON_COMMENT
,cast(null as int) as MON_FLOWING
,cast( null as int ) as MON_ID
,cast( 522 as int ) as DATA_ID
,cast( '20200810a' as varchar(255) ) as SYS_TEMP1
,cast( 20200810 as int ) as SYS_TEMP2
,row_number() over (order by dim.loc_id) as rkey
into moe_20200721.dbo.O_D_INTERVAL_MONITOR
from 
MOE_20200721.dbo.ORMGP_20200721_upd_DINTMON as dim
left outer join MOE_20200721.dbo._code_casing_material as moeccm
on dim.MON_SCREEN_MATERIAL=moeccm.CODE

Assemble the D_INTERVAL table.  Note that we're using an assigned date of '1867-07-01' for those missing INT_START_DATEs.  We're also using using a 'group by' statement to avoid creating duplicate interval/screen records.

select
t.LOC_ID
,t.INT_ID
,t.tmp_INT_ID
,cast( v.moe_well_id as varchar(255) ) as INT_NAME
,cast( t.tmp_int_id as varchar(255) ) as INT_NAME_ALT1
,t.tmp_INT_TYPE_CODE as INT_TYPE_CODE
,case 
when moe.date_completed is not null then moe.date_completed
else cast('1867-07-01' as datetime)
end as INT_START_DATE
,cast(1 as int) as INT_CONFIDENTIALITY_CODE
,cast(1 as int) as INT_ACTIVE
,cast( case
when t.int_id is not null then 1
else null
end as int) as int_exists
,cast(522 as int) as [DATA_ID]
,cast( '20200721a' as varchar(255) ) as SYS_TEMP1
,cast( 20200721 as int ) as SYS_TEMP2
,row_number() over (order by t.int_id) as rkey
into moe_20200721.dbo.O_D_INTERVAL
from 
(
select
dim.LOC_ID
,dim.INT_ID
,dim.tmp_INT_ID
,dim.tmp_INT_TYPE_CODE
from 
moe_20200721.dbo.O_D_INTERVAL_MONITOR as dim
group by
dim.loc_id,dim.tmp_int_id,dim.int_id,dim.tmp_int_type_code
) as t
inner join oak_20160831_master.dbo.v_sys_moe_locations as v
on t.tmp_int_id=v.moe_bore_hole_id
inner join moe_20200721.dbo.tblbore_hole as moe
on t.tmp_int_id=moe.bore_hole_id

Perform a check to make sure there are not any duplicate records in D_INTERVAL.  Correct/delete those rows (not shown).

Script: G_30_05_03_DINT_DIM.sql

We can now update those INT_IDs that already exist in the ORMDB as well as add any new intervals.  We'll update the INT_IDs first.

update oak_20160831_master.dbo.d_interval
set
int_name= d.int_name
,int_name_alt1= d.int_name_alt1
,int_type_code= d.int_type_code
,int_start_date= d.int_start_date
,int_confidentiality_code= d.int_confidentiality_code
,int_active= d.int_active
,data_id= d.data_id
,sys_temp1= d.sys_temp1
,sys_temp2= d.sys_temp2
from 
oak_20160831_master.dbo.d_interval as dint
inner join moe_20210119.dbo.o_d_interval as d
on dint.int_id=d.int_id
where 
d.int_exists=1
and
(
( d.int_start_date <> dint.int_start_date )
or
( d.int_type_code <> dint.int_type_code )
or
( d.int_name_alt1 <> dint.int_name_alt1 )
)

We'll need to create some random INT_IDs for the remainder (i.e. these intervals are not already present in the ORMDB).

update moe_20200721.dbo.o_d_interval
set
int_id= t2.int_id
from 
moe_20200721.dbo.o_d_interval as dint
inner join
(
select
t.int_id
,row_number() over (order by t.int_id) as rkey
from 
(
select
top 5200
v.new_id as int_id
from 
oak_20160831_master.dbo.v_sys_random_id_bulk_001 as v
where 
v.new_id not in
( select int_id from oak_20160831_master.dbo.d_interval )
) as t
) as t2
on dint.rkey=t2.rkey
where 
dint.int_exists is null

Insert them into D_INTERVAL.

insert into oak_20160831_master.dbo.d_interval
(
[LOC_ID], 
[INT_ID], 
[INT_NAME], 
[INT_NAME_ALT1], 
[INT_TYPE_CODE], 
[INT_START_DATE], 
[INT_CONFIDENTIALITY_CODE], 
[INT_ACTIVE],
[DATA_ID], 
[SYS_TEMP1], 
[SYS_TEMP2]
)
select
[LOC_ID], 
[INT_ID], 
[INT_NAME], 
[INT_NAME_ALT1], 
[INT_TYPE_CODE], 
[INT_START_DATE], 
[INT_CONFIDENTIALITY_CODE], 
[INT_ACTIVE],
[DATA_ID], 
[SYS_TEMP1], 
[SYS_TEMP2]
from 
moe_20200721.dbo.o_d_interval as d
where
d.int_exists is null

Now that the intervals are updated or created, we can update O_D_INTERVAL_MONITOR and then insert into D_INTERVAL_MONITOR.  First we'll associate the INT_ID.

update moe_20200721.dbo.o_d_interval_monitor
set
int_id= dint.int_id
from 
moe_20200721.dbo.o_d_interval_monitor as dim
inner join moe_20200721.dbo.o_d_interval as dint
on dim.tmp_int_id=dint.tmp_int_id
where
dint.int_exists is null

And then populate the MON_ID.

update moe_20200721.dbo.o_d_interval_monitor
set
mon_id= t2.mon_id
from 
moe_20200721.dbo.o_d_interval_monitor as d
inner join
(
select
t.mon_id
,row_number() over (order by t.mon_id) as rkey
from 
(
select
top 5200
v.new_id as mon_id
from 
oak_20160831_master.dbo.v_sys_random_id_bulk_001 as v
where 
v.new_id not in
( select mon_id from oak_20160831_master.dbo.d_interval_monitor )
) as t
) as t2
on d.id=t2.rkey

And, finally, add the new records into D_INTERVAL_MONITOR.

insert into oak_20160831_master.dbo.d_interval_monitor
(
[INT_ID], 
[MON_SCREEN_SLOT], 
[MON_SCREEN_MATERIAL], 
[MON_DIAMETER_OUOM], 
[MON_DIAMETER_UNIT_OUOM], 
[MON_TOP_OUOM], 
[MON_BOT_OUOM], 
[MON_UNIT_OUOM], 
[MON_COMMENT], 
[MON_FLOWING], 
[MON_ID], 
[DATA_ID], 
[SYS_TEMP1], 
[SYS_TEMP2]
)
select
[INT_ID], 
[MON_SCREEN_SLOT], 
[MON_SCREEN_MATERIAL], 
[MON_DIAMETER_OUOM], 
[MON_DIAMETER_UNIT_OUOM], 
[MON_TOP_OUOM], 
[MON_BOT_OUOM], 
[MON_UNIT_OUOM], 
[MON_COMMENT], 
[MON_FLOWING], 
[MON_ID], 
[DATA_ID], 
[SYS_TEMP1], 
[SYS_TEMP2]
from
moe_20200721.dbo.o_d_interval_monitor as odim
where
odim.int_id not in
( select distinct(int_id) from oak_20160831_master.dbo.d_interval_monitor )

Script: G_30_05_04_DINT_DIM_ADD.sql

Note that the MON_FLOWING field may need to be updated in a future step.

G.30.6 D_INTERVAL_REF_ELEV

For these new or updated intervals, we'll check and correct (or add to) the intervals in the D_INTERVAL_REF_ELEV table.  We should first make sure that an elevation has been assigned in the D_BOREHOLE table (as we're actually calculating a reference elevation, herein, we'll need the ground elevation at the location).  Note that we're using the temporary D_INTERVAL table to determine which intervals need to be updated.

-- create view V_MOE_20200721_UPD_ELEVS as
select
dbore.loc_id
,dloc.loc_coord_easting as x
,dloc.loc_coord_northing as y
from 
moe_20200721.dbo.o_d_interval as dint
inner join oak_20160831_master.dbo.d_borehole as dbore
on dint.loc_id=dbore.loc_id
inner join oak_20160831_master.dbo.d_location as dloc
on dbore.loc_id=dloc.loc_id
left outer join oak_20160831_master.dbo.d_interval_ref_elev as dire
on dint.int_id=dire.int_id
where 
( dire.int_id is null or dire.ref_elev is null )
and dbore.bh_gnd_elev is null

We'll create a view from this, determine the elevations and populate the D_BOREHOLE table (not shown).  Now we can create the temporary D_INTERVAL_REF_ELEV table.

select
dint.INT_ID
,dire.SYS_RECORD_ID
,dint.int_start_date as REF_ELEV_START_DATE
,( dbore.bh_gnd_elev + 0.75 ) as REF_ELEV
,( dbore.bh_gnd_elev + 0.75 ) as REF_ELEV_OUOM
,cast('masl' as varchar(50)) as REF_ELEV_UNIT_OUOM
,0.75 as REF_STICK_UP
,cast('0.75' as varchar(50)) as REF_POINT
,cast( 522 as int ) as DATA_ID
,cast( '20200810a' as varchar(255) ) as SYS_TEMP1
,cast( 20200810 as int ) as SYS_TEMP2
,case
when dire.int_id is not null then 1
else null
end as int_exists
,row_number() over (order by dint.int_id) as rkey
into moe_20200721.dbo.O_D_INTERVAL_REF_ELEV
from 
moe_20200721.dbo.o_d_interval as dint
inner join oak_20160831_master.dbo.d_borehole as dbore
on dint.loc_id=dbore.loc_id
left outer join oak_20160831_master.dbo.d_interval_ref_elev as dire
on dint.int_id=dire.int_id
where 
dire.int_id is null
or dire.ref_elev is null

And then populate the NULL SYS_RECORD_IDs.

update moe_20200721.dbo.o_d_interval_ref_elev
set
sys_record_id= t2.sri
from 
moe_20200721.dbo.o_d_interval_ref_elev as dire
inner join
(
select
t.sri
,row_number() over (order by t.sri) as rkey
from 
(
select
top 1500
v.new_id as sri
from 
oak_20160831_master.dbo.v_sys_random_id_bulk_001 as v
where 
v.new_id not in
( select sys_record_id from oak_20160831_master.dbo.d_interval_ref_elev )
) as t
) as t2
on dire.rkey=t2.rkey
where 
dire.int_exists is null

We can update the fields for those INT_IDs (actually through SYS_RECORD_ID) that already exist in the ORMDB.

update oak_20160831_master.dbo.d_interval_ref_elev
set 
ref_elev_start_date= m.ref_elev_start_date
,ref_elev= m.ref_elev
,ref_elev_ouom= m.ref_elev_ouom
,ref_elev_unit_ouom= m.ref_elev_unit_ouom
,ref_stick_up= m.ref_stick_up
,ref_point= m.ref_point
,data_id= m.data_id
,sys_temp1= m.sys_temp1
,sys_temp2= m.sys_temp2
from 
oak_20160831_master.dbo.d_interval_ref_elev as dire
inner join moe_20200721.dbo.o_d_interval_ref_elev as m
on dire.sys_record_id=m.sys_record_id
where 
m.int_exists is not null

And we can insert the remainder.

insert into oak_20160831_master.dbo.d_interval_ref_elev
(
[INT_ID], 
[SYS_RECORD_ID], 
[REF_ELEV_START_DATE], 
[REF_ELEV], 
[REF_ELEV_OUOM], 
[REF_ELEV_UNIT_OUOM], 
[REF_STICK_UP], 
[REF_POINT], 
[DATA_ID], 
[SYS_TEMP1], 
[SYS_TEMP2]
)
select 
[INT_ID], 
[SYS_RECORD_ID], 
[REF_ELEV_START_DATE], 
[REF_ELEV], 
[REF_ELEV_OUOM], 
[REF_ELEV_UNIT_OUOM], 
[REF_STICK_UP], 
[REF_POINT], 
[DATA_ID], 
[SYS_TEMP1], 
[SYS_TEMP2]
from 
moe_20200721.dbo.o_d_interval_ref_elev as m
where 
m.int_exists is null

Script: G_30_06_01_DIRE.sql

G.30.7 D_INTERVAL_TEMPORAL_2 - Static Waterlevels

We will not rely upon the interval list generated in Section G.30.5, previously.  This was tested (i.e. limited to the interval list) and only returns a subset of the missing values.  Instead, we'll build the values to be incorporated from the complete list of MOEDB related boreholes.

select
dint.int_id
,v.moe_bore_hole_id
into moe_20200721.dbo.ORMGP_20200721_upd_DIT2_628
from 
oak_20160831_master.dbo.v_sys_moe_locations as v
inner join oak_20160831_master.dbo.v_sys_agency_ypdt as y
on v.loc_id=y.loc_id
inner join oak_20160831_master.dbo.d_interval as dint
on v.loc_id=dint.loc_id
left outer join
(
select
int_id
from 
oak_20160831_master.dbo.d_interval_temporal_2
where 
rd_type_code=0
and rd_name_code=628
group by
int_id
) as d2
on dint.int_id=d2.int_id
inner join moe_20200721.dbo.tblpipe as moetp
on v.moe_bore_hole_id=moetp.bore_hole_id
inner join moe_20200721.dbo.tblpump_test as moept
on moetp.pipe_id=moept.pipe_id
where 
d2.int_id is null
and moept.static_lev is not null
group by
dint.int_id,v.moe_bore_hole_id

We can now use this list to generate the D_INTERVAL_TEMPORAL_2 compatible table containing the static water levels.

select 
dbore.LOC_ID
,dint.INT_ID
,cast(0 as int) as RD_TYPE_CODE
,cast(628 as int) as RD_NAME_CODE
,case
when dint.int_start_date is null then cast( '1867-07-01' as datetime ) 
else dint.INT_START_DATE 
end as [RD_DATE]
,cast(
case
when moept.LEVELS_UOM like 'ft' then dbore.bh_gnd_elev-(0.3048*moept.Static_lev) 
else dbore.bh_gnd_elev-moept.Static_lev 
end
as float
) as[RD_VALUE]
,cast(6 as int) as UNIT_CODE
,cast('Water Level - Manual - Static' as varchar(255)) as RD_NAME_OUOM
,cast(moept.Static_lev as float) as [RD_VALUE_OUOM]
,cast(moept.LEVELS_UOM as varchar(50)) as [RD_UNIT_OUOM]
,cast(1 as int) as [REC_STATUS_CODE]
,cast(null as varchar(255)) as RD_COMMENT
,cast(522 as int) as DATA_ID
,cast(null as int) as SYS_RECORD_ID
,ROW_NUMBER() over (order by dint.INT_ID) as rkey
into moe_20200721.dbo.O_D_INTERVAL_TEMPORAL_2_628
from 
moe_20200721.dbo.ormgp_20200721_upd_dit2_628 as d2
inner join moe_20200721.dbo.tblpipe as moetp
on d2.moe_bore_hole_id=moetp.bore_hole_id
inner join moe_20200721.dbo.tblpump_test as moept
on moetp.pipe_id=moept.pipe_id
inner join oak_20160831_master.dbo.d_interval as dint
on d2.int_id=dint.int_id
inner join oak_20160831_master.dbo.d_borehole as dbore
on dint.loc_id=dbore.loc_id

Check this table (i.e. O_D_INTERVAL_TEMPORAL_2_628) for NULL RD_VALUE fields - these do not have a valid BH_GND_ELEV value in D_BOREHOLE.  Fix this issue (not shown) then re-create the table (using the above script).  We will now populate the SYS_RECORD_ID field.

update moe_20200721.dbo.o_d_interval_temporal_2_628
set
sys_record_id= t2.sri
from 
moe_20200721.dbo.o_d_interval_temporal_2_628 as d
inner join
(
select
t.sri
,row_number() over (order by t.sri) as rkey
from 
(
select
top 3000
v.new_id as sri
from 
oak_20160831_master.dbo.v_sys_random_id_bulk_001 as v
where 
v.new_id not in
( select sys_record_id from oak_20160831_master.dbo.d_interval_temporal_2 )
) as t
) as t2
on d.rkey=t2.rkey

And insert the values into D_INTERVAL_TEMPORAL_2.

insert into oak_20160831_master.dbo.d_interval_temporal_2
(
[INT_ID], 
[RD_TYPE_CODE], 
[RD_NAME_CODE], 
[RD_DATE], 
[RD_VALUE], 
[UNIT_CODE], 
[RD_NAME_OUOM], 
[RD_VALUE_OUOM], 
[RD_UNIT_OUOM], 
[REC_STATUS_CODE], 
[RD_COMMENT], 
[DATA_ID],
SYS_TEMP1,
SYS_TEMP2, 
[SYS_RECORD_ID]
)
select
[INT_ID], 
[RD_TYPE_CODE], 
[RD_NAME_CODE], 
[RD_DATE], 
[RD_VALUE], 
[UNIT_CODE], 
[RD_NAME_OUOM], 
[RD_VALUE_OUOM], 
[RD_UNIT_OUOM], 
[REC_STATUS_CODE], 
[RD_COMMENT], 
[DATA_ID],
cast( '20200810b' as varchar(255) ) as SYS_TEMP1,
cast( 20200810 as int ) as SYS_TEMP2, 
[SYS_RECORD_ID]
from 
moe_20200721.dbo.o_d_interval_temporal_2_628

Script: G_30_07_01_DIT2_628.sql

G.30.8 D_PUMPTEST and related

We should first check and update the status of flowing wells in the ORMDB as tagged in the MOEDB (this information is found in the 'tblpump_test' table in the latter).

update oak_20160831_master.dbo.d_interval_monitor
set
mon_flowing= 1
,data_id= case
when dim.data_id is null then 522
else dim.data_id
end
,mon_comment= case
when dim.data_id is null then 'MON_FLOWING update from DATA_ID 522'
else dim.mon_comment + '; MON_FLOWING update from DATA_ID 522'
end
,sys_temp1= cast( '20200810c' as varchar(255) )
,sys_temp2= cast( 20200810 as int )
from 
oak_20160831_master.dbo.d_interval_monitor as dim
inner join oak_20160831_master.dbo.d_interval as dint
on dim.int_id=dint.int_id
inner join oak_20160831_master.dbo.v_sys_moe_locations as v
on dint.loc_id=v.loc_id
inner join oak_20160831_master.dbo.v_sys_agency_ypdt as y
on v.loc_id=y.loc_id
inner join moe_20200721.dbo.tblpipe as moetp
on v.moe_bore_hole_id=moetp.bore_hole_id
inner join moe_20200721.dbo.tblpump_test as moept
on moetp.pipe_id=moept.pipe_id
where 
moept.FLOWING like 'Y'
and dim.mon_flowing is null
and dint.int_type_code in 
( select int_type_code from oak_20160831_master.dbo.v_sys_int_type_code_screen )

We can now assemble those INT_IDs (and related) that require pumping information to be added.

select
dint.int_id
,v.moe_well_id
,v.moe_bore_hole_id
,moept.pipe_id
into moe_20200721.dbo.ORMGP_20200721_upd_DPUMP
from 
oak_20160831_master.dbo.v_sys_moe_locations as v
inner join oak_20160831_master.dbo.v_sys_agency_ypdt as y
on v.loc_id=y.loc_id
inner join oak_20160831_master.dbo.d_interval as dint
on v.loc_id=dint.loc_id
left outer join
(
select
int_id
from 
oak_20160831_master.dbo.d_pumptest
group by
int_id
) as d
on dint.int_id=d.int_id
inner join moe_20200721.dbo.tblpipe as moetp
on v.moe_bore_hole_id=moetp.bore_hole_id
inner join moe_20200721.dbo.tblpump_test as moept
on moetp.pipe_id=moept.pipe_id
where 
d.int_id is null
-- there are non-screen intervals, make sure not to include them
and dint.int_type_code in ( select int_type_code from oak_20160831_master.dbo.v_sys_int_type_code_screen )
and (
moept.Recom_depth is not null 
or moept.Recom_rate is not null 
or moept.Flowing_rate is not null 
or moept.PUMP_TEST_ID in 
(select PUMP_TEST_ID from moe_20200721.dbo.tblpump_test_detail)
)

And then assemble the temporary O_D_PUMPTEST table.

select 
d.INT_ID
,cast( null as int ) as PUMP_TEST_ID
,moept.pump_test_id as moe_pump_test_id
,case
when dint.int_start_date is not null then dint.int_start_date
else cast( '1867-07-01' as datetime ) 
end as PUMPTEST_DATE
,cast(d.moe_well_id as varchar(20)) as PUMPTEST_NAME
,cast(
case 
when moept.LEVELS_UOM='ft' then moept.Recom_depth*0.3048
else moept.Recom_depth
end as float) as [REC_PUMP_DEPTH_METERS]
,cast(
case 
when moept.RATE_UOM='LPM' then moept.Recom_rate/4.55
else moept.Recom_rate
end as float) as [REC_PUMP_RATE_IGPM]
,cast(
case 
when moept.RATE_UOM='LPM' then moept.Flowing_rate/4.55
else moept.Flowing_rate
end as float) as [FLOWING_RATE_IGPM]
,cast(522 as int) as [DATA_ID]
,cast(
case 
when moept.PUMPING_TEST_METHOD is null then null 
when moept.PUMPING_TEST_METHOD=0       then null
when moept.PUMPING_TEST_METHOD=1       then 1
when moept.PUMPING_TEST_METHOD=2       then 2
when moept.PUMPING_TEST_METHOD=3       then 4
when moept.PUMPING_TEST_METHOD=4       then 8
when moept.PUMPING_TEST_METHOD=5       then 9
else 10
end as int) as [PUMPTEST_METHOD_CODE]
,cast(1 as int) as [PUMPTEST_TYPE_CODE]  -- this is a constant rate indicator
,cast(
case
when moept.WATER_STATE_AFTER_TEST is null then 0
else moept.WATER_STATE_AFTER_TEST
end as int) as [WATER_CLARITY_CODE]
,ROW_NUMBER() over (order by dint.INT_ID) as rkey
into moe_20200721.dbo.O_D_PUMPTEST
from 
moe_20200721.dbo.TblPump_Test as moept
inner join moe_20200721.dbo.ormgp_20200721_upd_dpump as d
on moept.pipe_id=d.pipe_id
inner join oak_20160831_master.dbo.d_interval as dint
on d.int_id=dint.int_id

Now, corresponding to the methodology in G.10.19, we'll adjust the MON_FLOWING tag in D_INTERVAL_MONITOR (as well as related fields in various other tables).  We will also modify the FLOWING_RATE_IGPM (as necessary). First, do we have a null MON_FLOWING while REC_PUMP_RATE_IGPM equals FLOWING_RATE_IGPM - if so, make FLOWING_RATE_IGPM null.

update moe_20200721.dbo.o_d_pumptest
set
flowing_rate_igpm=null
from 
moe_20200721.dbo.o_d_pumptest as d
where
d.INT_ID
not in
(
select
dim.INT_ID
from 
oak_20160831_master.dbo.d_interval_monitor as dim
where
dim.MON_FLOWING is not null 
)
and d.REC_PUMP_RATE_IGPM=d.FLOWING_RATE_IGPM

Next, there is no REC_PUMP_RATE_IGPM but there is a FLOWING_RATE_IGPM - tag MON_FLOWING.

update oak_20160831_master.dbo.d_interval_monitor
set 
mon_flowing=1
from 
oak_20160831_master.dbo.d_interval_monitor as dim
where
dim.INT_ID
in
(
select 
d.INT_ID 
from 
moe_20200721.dbo.o_d_pumptest as d
where
d.INT_ID
in 
(
select
d2.INT_ID
from 
oak_20160831_master.dbo.d_interval_monitor as d2
where
d2.MON_FLOWING is null 
)
and d.REC_PUMP_RATE_IGPM is null 
and d.FLOWING_RATE_IGPM is not null 
)

If the FLOWING_RATE_IGPM is less than the REC_PUMP_RATE_IGPM and MON_FLOWING is not tagged, tag MON_FLOWING.

update oak_20160831_master.dbo.d_interval_monitor
set 
mon_flowing=1
from 
oak_20160831_master.dbo.d_interval_monitor as dim
where
dim.INT_ID
in
(
select 
d.INT_ID 
from 
moe_20200721.dbo.o_d_pumptest as d
where
d.INT_ID
in 
(
select
d2.INT_ID
from 
oak_20160831_master.dbo.d_interval_monitor as d2
where
d2.MON_FLOWING is null 
)
and d.REC_PUMP_RATE_IGPM is null 
and d.FLOWING_RATE_IGPM is not null 
)

If the FLOWING_RATE_IGPM is greater than REC_PUMP_RATE_IGPM and MON_FLOWING is not tagged, null the FLOWING_RATE_IGPM (this is considered an error).

update moe_20200721.dbo.o_d_pumptest
set
flowing_rate_igpm=null
from 
moe_20200721.dbo.o_d_pumptest as dpump
where
dpump.INT_ID
in
(
select 
d.INT_ID 
from 
moe_20200721.dbo.o_d_pumptest as d
where
d.INT_ID
in 
(
select
d2.INT_ID
from 
oak_20160831_master.dbo.d_interval_monitor as d2
where
d2.MON_FLOWING is null 
)
and dpump.FLOWING_RATE_IGPM>dpump.REC_PUMP_RATE_IGPM
)

Script: G_30_08_01_DPUMP.sql

We can now build the pumping drawdown (i.e. 'D') and recovery (i.e. 'R') information for the particular pump tests (as determined in the previous step).  First the drawdown information.

select
curr.Pump_Test_id as moe_pump_test_id
,cast(moept.Pumping_rate as float) as PUMP_RATE
,cast(moept.RATE_UOM as varchar(50)) as PUMP_RATE_UNITS
,cast(moept.Pumping_rate as float) as PUMP_RATE_OUOM
,cast(moept.RATE_UOM as varchar(50)) as PUMP_RATE_UNITS_OUOM
,dateadd(minute,curr.TestDuration,dpump.PUMPTEST_DATE) as [PUMP_START]
,dateadd(minute,prev.TestDuration,dpump.PUMPTEST_DATE) as [PUMP_END]
,cast(521 as int) as DATA_ID
,null as [SYS_RECORD_ID]
,null as [rkey]
,prev.TestType as [testtype]
,prev.TestLevel as [testlevel]
,prev.TESTLEVEL_UOM as [testlevel_uom]
into MOE_20200721.dbo.ORMGP_20200721_upd_DPUMPSTEP
from
(
	select
	moeptd.Pump_Test_id
	,moeptd.TestDuration
	,ROW_NUMBER() over (order by moeptd.Pump_Test_id,moeptd.TestDuration) as rnum
	from 
	MOE_20200721.dbo.TblPump_Test_Detail as moeptd
	where 
	moeptd.TestType='D'
) as [curr]
inner join 
(
	select
	moeptd.Pump_Test_id
	,moeptd.TestDuration
	,moeptd.TestLevel
	,moeptd.TestType
	,moeptd.TESTLEVEL_UOM
	,ROW_NUMBER() over (order by moeptd.Pump_Test_id,moeptd.TestDuration) as rnum
	from 
	MOE_20200721.dbo.TblPump_Test_Detail as moeptd
	where 
	moeptd.TestType='D'
) as [prev]
on curr.Pump_Test_id=prev.Pump_Test_id and curr.rnum=(prev.rnum-1)
inner join MOE_20200721.dbo.TblPump_Test as moept
on curr.Pump_Test_id=moept.PUMP_TEST_ID
inner join moe_20200721.dbo.o_d_pumptest as dpump
on curr.pump_test_id=dpump.moe_pump_test_id
order by 
curr.Pump_Test_id,PUMP_START

Now we can create the first time step - add to the previous table.

insert into MOE_20200721.dbo.ORMGP_20200721_upd_DPUMPSTEP
(
moe_pump_test_id
,[PUMP_RATE]
,[PUMP_RATE_UNITS]
,[PUMP_RATE_OUOM]
,[PUMP_RATE_UNITS_OUOM]
,[PUMP_START]
,[PUMP_END]
,[DATA_ID]
,[SYS_RECORD_ID]
,[rnum]
,[testtype]
,[testlevel]
,[testlevel_uom]
)
select
curr.Pump_Test_id as moe_pump_test_id
,cast(moept.Pumping_rate as float) as PUMP_RATE
,cast(moept.RATE_UOM as varchar(50)) as PUMP_RATE_UNITS
,cast(moept.Pumping_rate as float) as PUMP_RATE_OUOM
,cast(moept.RATE_UOM as varchar(50)) as PUMP_RATE_UNITS_OUOM
,dateadd(minute,0,dpump.PUMPTEST_DATE) as [PUMP_START]
,dateadd(minute,curr.TestDuration,dpump.PUMPTEST_DATE) as [PUMP_END]
,cast(521 as int) as DATA_ID
,cast(null as int) as [SYS_RECORD_ID]
,cast(null as int) as [rkey]
,moeptd.TestType as [testtype]
,moeptd.TestLevel as [testlevel]
,moeptd.TESTLEVEL_UOM as [testlevel_uom]
from
(
    select 
    moeptd.Pump_Test_id
    ,min(moeptd.TestDuration) as TestDuration
    from 
	MOE_20200721.dbo.TblPump_Test_Detail as moeptd
	where 
	moeptd.TestType='D' 
	group by
	moeptd.Pump_Test_id
) as curr
inner join MOE_20200721.dbo.TblPump_Test as moept
on curr.Pump_Test_id=moept.PUMP_TEST_ID
inner join MOE_20200721.dbo.TblPump_Test_Detail as moeptd
on curr.Pump_Test_id=moeptd.Pump_Test_id and curr.TestDuration=moeptd.TestDuration
inner join moe_20200721.dbo.o_d_pumptest as dpump
on curr.pump_test_id=dpump.moe_pump_test_id
where
moeptd.TestType='D'
order by 
curr.Pump_Test_id,PUMP_START

Now add the pumping recovery information (based upon the maximum datetime for the particular PUMP_TEST_ID).

insert into moe_20200721.dbo.ormgp_20200721_upd_dpumpstep
(
moe_pump_test_id
,pump_end
,data_id
,sys_record_id
,rnum
,testtype
,testlevel
,testlevel_uom
)
select
curr.Pump_Test_id as moe_pump_test_id
,dateadd(minute,curr.TestDuration,mt.enddate) as [PUMP_END]
,cast(522 as int) as DATA_ID
,null as [SYS_RECORD_ID]
,null as [rnum]
,curr.TestType as [testtype]
,curr.TestLevel as [testlevel]
,curr.TESTLEVEL_UOM as [testlevel_uom]
from
(
	select
	moeptd.Pump_Test_id
	,moeptd.TestDuration
	,moeptd.TestType
	,moeptd.TestLevel
	,moeptd.TESTLEVEL_UOM
	from 
	MOE_20200721.dbo.TblPump_Test_Detail as moeptd
	where 
	moeptd.TestType='R'
) as [curr]
inner join 
(
	select 
	ycps.moe_Pump_Test_id
	,max(ycps.PUMP_END) as enddate
	from 
	MOE_20200721.dbo.ORMGP_20200721_upd_dpumpstep as ycps
	where 
	ycps.TestType='D' 
	group by
	ycps.moe_Pump_Test_id
) as mt
on curr.Pump_Test_id=mt.moe_Pump_Test_id
inner join MOE_20200721.dbo.TblPump_Test as moept
on curr.Pump_Test_id=moept.PUMP_TEST_ID
inner join MOE_20200721.dbo.o_D_PUMPTEST as dpump
on curr.Pump_Test_id=dpump.pump_test_id
order by 
curr.Pump_Test_id,PUMP_END

Create the O_D_PUMPTEST_STEP table based upon a grouping of the grouping of pumping rate and units.  Note that only the drawdown information is being used.

select
cast( null as int ) as PUMP_TEST_ID
,t1.moe_PUMP_TEST_ID
,t1.PUMP_RATE
,t1.PUMP_RATE_UNITS
,t1.PUMP_RATE_OUOM
,t1.PUMP_RATE_UNITS_OUOM
,t1.PUMP_START
,t1.PUMP_END
,cast(522 as int) as DATA_ID
,t1.SYS_RECORD_ID
,t1.rkey
into MOE_20200721.dbo.O_D_PUMPTEST_STEP 
from 
(
SELECT
[moe_PUMP_TEST_ID]
,[PUMP_RATE]
,[PUMP_RATE_UNITS]
,[PUMP_RATE_OUOM]
,[PUMP_RATE_UNITS_OUOM]
,min([PUMP_START]) as [PUMP_START]
,max([PUMP_END]) as [PUMP_END]
,cast( null as int ) as SYS_RECORD_ID
,ROW_NUMBER() over (order by moe_PUMP_TEST_ID) as rkey
FROM MOE_20200721.[dbo].ormgp_20200721_upd_dpumpstep
where 
testtype='D'
group by
moe_Pump_Test_id,PUMP_RATE,PUMP_RATE_UNITS,PUMP_RATE_OUOM,PUMP_RATE_UNITS_OUOM 
) as t1

We can now add the pumping and recovery water levels into a compatible D_INTERVAL_TEMPORAL_2 table.  Add an index to this table.

select
dp.INT_ID
,case 
when dps.testtype='D' then cast(65 as int) -- i.e. moe pumping level
else cast(64 as int) -- i.e. moe recovery level
end as [RD_TYPE_CODE]
,cast(70899 as int) as [RD_NAME_CODE]  -- i.e. Water Level - Manual - Other
,dps.PUMP_END as [RD_DATE]
,case
when dps.testlevel_uom='m' then dbore.bh_gnd_elev - dps.testlevel
else dbore.bh_gnd_elev - (dps.testlevel*0.3048)
end as [RD_VALUE]
,cast(6 as int) as [UNIT_CODE]
,cast('Water Level - Manual - Other' as varchar(100)) as RD_NAME_OUOM
,cast(dps.testlevel as float) as RD_VALUE_OUOM
,cast(dps.testlevel_uom as varchar(50)) as RD_UNIT_OUOM
,cast(1 as int) as REC_STATUS_CODE
,cast(
case 
when dps.testtype='D' then 'Pumping - Drawdown'
else 'Pumping - Recovery'
end as varchar(255) ) as [RD_COMMENT]
,dps.DATA_ID as [DATA_ID]
,dps.SYS_RECORD_ID
,dps.rkey
into moe_20200721.dbo.O_D_INTERVAL_TEMPORAL_2_70899
from 
MOE_20200721.[dbo].ORMGP_20200721_upd_DPUMPSTEP as dps
inner join MOE_20200721.dbo.O_D_PUMPTEST as dp
on dps.moe_PUMP_TEST_ID=dp.moe_PUMP_TEST_ID
inner join oak_20160831_master.dbo.d_interval as dint
on dp.int_id=dint.int_id
inner join oak_20160831_master.dbo.d_borehole as dbore
on dint.loc_id=dbore.loc_id
where
dps.testtype is not null
and dbore.bh_gnd_elev is not null
order by
dp.INT_ID,RD_DATE

Finally populate the SYS_RECORD_ID field.

update moe_20200721.dbo.o_d_interval_temporal_2_70899
set
sys_record_id= t2.sri
from 
moe_20200721.dbo.o_d_interval_temporal_2_70899 as d
inner join
(
select
t.sri
,row_number() over (order by t.sri) as rkey
from 
(
select
top 15000
v.new_id as sri
from 
oak_20160831_master.dbo.v_sys_random_id_bulk_001 as v
where 
v.new_id not in
( select sys_record_id from oak_20160831_master.dbo.d_interval_temporal_2 ) 
) as t
) as t2
on d.rkey=t2.rkey

And then insert into the D_INTERVAL_TEMPORAL_2 table.

insert into oak_20160831_master.dbo.d_interval_temporal_2
(
[INT_ID], 
[RD_TYPE_CODE], 
[RD_NAME_CODE], 
[RD_DATE], 
[RD_VALUE], 
[UNIT_CODE], 
[RD_NAME_OUOM], 
[RD_VALUE_OUOM], 
[RD_UNIT_OUOM], 
[REC_STATUS_CODE], 
[RD_COMMENT], 
[DATA_ID], 
[SYS_RECORD_ID],
SYS_TEMP1,
SYS_TEMP2
)
select
[INT_ID], 
[RD_TYPE_CODE], 
[RD_NAME_CODE], 
[RD_DATE], 
[RD_VALUE], 
[UNIT_CODE], 
[RD_NAME_OUOM], 
[RD_VALUE_OUOM], 
[RD_UNIT_OUOM], 
[REC_STATUS_CODE], 
[RD_COMMENT], 
[DATA_ID], 
[SYS_RECORD_ID],
cast( '20200811a' as varchar(255) ) as SYS_TEMP1,
cast( 20200811 as int ) as SYS_TEMP2
from 
moe_20200721.dbo.o_d_interval_temporal_2_70899

Script: G_30_08_02_DPUMPSTEP.sql

We'll now incorporate the information from the pumping tables into the ORMDB.  Create the PUMP_TEST_ID values for O_D_PUMPTEST.

update moe_20200721.dbo.o_d_pumptest
set
pump_test_id= t2.pump_test_id
from 
moe_20200721.dbo.o_d_pumptest as d
inner join 
(
select
t.pump_test_id
,row_number() over (order by t.pump_test_id) as rkey
from 
(
select
top 2000
v.new_id as pump_test_id
from 
oak_20160831_master.dbo.v_sys_random_id_bulk_001 as v
where 
v.new_id not in 
( select pump_test_id from oak_20160831_master.dbo.d_pumptest )
) as t
) as t2
on d.rkey=t2.rkey

Insert these values into D_PUMPTEST.

insert into oak_20160831_master.dbo.d_pumptest
(
[INT_ID], 
[PUMP_TEST_ID], 
[PUMPTEST_DATE], 
[PUMPTEST_NAME], 
[REC_PUMP_DEPTH_METERS], 
[REC_PUMP_RATE_IGPM], 
[FLOWING_RATE_IGPM], 
[DATA_ID], 
[PUMPTEST_METHOD_CODE], 
[PUMPTEST_TYPE_CODE], 
[WATER_CLARITY_CODE], 
SYS_TEMP1,
SYS_TEMP2
)
select
[INT_ID], 
[PUMP_TEST_ID], 
[PUMPTEST_DATE], 
[PUMPTEST_NAME], 
[REC_PUMP_DEPTH_METERS], 
[REC_PUMP_RATE_IGPM], 
[FLOWING_RATE_IGPM], 
[DATA_ID], 
[PUMPTEST_METHOD_CODE], 
[PUMPTEST_TYPE_CODE], 
[WATER_CLARITY_CODE], 
cast( '20200811b' as varchar(255) ) as SYS_TEMP1,
cast( 20200811 as int ) as SYS_TEMP2
from 
moe_20200721.dbo.o_d_pumptest

Now, update the PUMP_TEST_ID field in O_D_PUMPTEST_STEP.

update moe_20200721.dbo.o_d_pumptest_step
set
pump_test_id= dp.pump_test_id
from 
moe_20200721.dbo.o_d_pumptest_Step as dps
inner join moe_20200721.dbo.o_d_pumptest as dp
on dps.moe_pump_test_id=dp.moe_pump_test_id

And then populate the SYS_RECORD_ID field.

update moe_20200721.dbo.o_d_pumptest_step
set
sys_record_id= t2.sri
from 
moe_20200721.dbo.o_d_pumptest_step as d
inner join
(
select
t.sri
,row_number() over (order by t.sri) as rkey
from 
(
select
top 1600
v.new_id as sri
from 
oak_20160831_master.dbo.v_sys_random_id_bulk_001 as v
where 
v.new_id not in
( select sys_record_id from oak_20160831_master.dbo.d_pumptest_step )
) as t
) as t2
on d.rkey=t2.rkey

Finally, insert this information into D_PUMPTEST_STEP.

insert into oak_20160831_master.dbo.d_pumptest_step
(
[PUMP_TEST_ID], 
[PUMP_RATE], 
[PUMP_RATE_UNITS], 
[PUMP_RATE_OUOM], 
[PUMP_RATE_UNITS_OUOM], 
[PUMP_START], 
[PUMP_END], 
[DATA_ID], 
[SYS_RECORD_ID], 
SYS_TEMP1,
SYS_TEMP2
)
select
[PUMP_TEST_ID], 
[PUMP_RATE], 
[PUMP_RATE_UNITS], 
[PUMP_RATE_OUOM], 
[PUMP_RATE_UNITS_OUOM], 
[PUMP_START], 
[PUMP_END], 
[DATA_ID], 
[SYS_RECORD_ID], 
cast( '20200811b' as varchar(255) ) as SYS_TEMP1,
cast( 20200811 as int ) as SYS_TEMP2
from 
moe_20200721.dbo.o_d_pumptest_step

Script: G_30_08_03_DPID.sql

G.31 Incorporate D_LOCATION_COORD_HIST and D_LOCATION_ELEV_HIST records into D_LOCATION_SPATIAL_HIST

Tables

    - D_LOCATION
    - D_LOCATION_COORD_HIST
    - D_LOCATION_ELEV
    - D_LOCATION_ELEV_HIST
    - D_LOCATION_QA
    - D_LOCATION_SPATIAL
    - D_LOCATION_SPATIAL_HIST

Estimated Recurrence Time: Single database update due to methodology change.

The tables D_LOCATION_COORD_HIST and D_LOCATION_ELEV_HIST functionality is to be combined in a single table - D_LOCATION_SPATIAL_HIST - to more closely link coordinates and elevations.  The original methodology, using the two disparate tables, was found to be inadequate with regard to timely (or, at all) tracking of changes in one or the other of location or elevation without the values becoming disassociated (i.e. one value no longer related to the other).  If this information is found in a single table, it is thought, that can be updated with a new record resulting from any change the likelihood of the location and the elevation being unrelated should be lessened.

Current coordinates and elevation, which should be recorded in the appropriate tables, is added into the D_LOCATION_SPATIAL_HIST table.  Note that the conversion of LOC_COORD_OUOM_CODE from D_LOCATION (to the appropriate EPSG code) occurs within the query.  Where assumptions are made concerning this conversion (as originally found in R_LOC_COORD_OUOM_CODE), these are recorded in the EPSG_CODE_COMMENT field.  All pertinent comment (or text) fields from the various tables are appended into the coordinate or elevation method/comment fields in D_LOCATION_SPATIAL_HIST (zero-length text fields are converted to NULL values - not shown here).  Differing dates from the variety of tables is examined with the most relevant date used to populate each of the date fields in the new table.  Note that the choice of information used should be consistent through each of the following steps. 

select
dloc.loc_id
,case
when dlch.loc_coord_hist_code is not null then dlch.loc_coord_hist_code
else 1
end as loc_coord_hist_code
,case
when dlch.sys_time_stamp is not null then dlch.sys_time_stamp
when dloc.sys_last_modified is not null then dloc.sys_last_modified
else getdate()
end as loc_coord_date
,dloc.loc_coord_easting as x
,dloc.loc_coord_northing as y
,cast(26917 as int) as epsg_code
,case
-- the original coordinates in these cases are invalid
when dloc.loc_coord_ouom_code in ( 25, 29, 31, 33, 35 ) then null
else dloc.loc_coord_easting_ouom 
end as x_ouom
,case 
-- the original coordinates in these cases are invalid
when dloc.loc_coord_ouom_code in ( 25, 29, 31, 33, 35 ) then null
else dloc.loc_coord_northing_ouom 
end as y_ouom
,case
when dloc.loc_coord_ouom_code=  1 then null
when dloc.loc_coord_ouom_code=  2 then 26717
when dloc.loc_coord_ouom_code=  3 then 26718
when dloc.loc_coord_ouom_code=  4 then 26917
when dloc.loc_coord_ouom_code=  5 then 26918
when dloc.loc_coord_ouom_code=  6 then 26910
when dloc.loc_coord_ouom_code=  7 then 26915
when dloc.loc_coord_ouom_code=  8 then 26916
when dloc.loc_coord_ouom_code=  9 then 26919
when dloc.loc_coord_ouom_code= 10 then 26917
when dloc.loc_coord_ouom_code= 11 then 26717
when dloc.loc_coord_ouom_code= 12 then 26717
when dloc.loc_coord_ouom_code= 13 then 32190
when dloc.loc_coord_ouom_code= 14 then 7991
when dloc.loc_coord_ouom_code= 15 then 32190
when dloc.loc_coord_ouom_code= 16 then 32196
when dloc.loc_coord_ouom_code= 17 then 26917
when dloc.loc_coord_ouom_code= 18 then 4267
when dloc.loc_coord_ouom_code= 19 then 4269
when dloc.loc_coord_ouom_code= 20 then 4269
when dloc.loc_coord_ouom_code= 21 then 4269
when dloc.loc_coord_ouom_code= 22 then 26917
when dloc.loc_coord_ouom_code= 23 then 26918
when dloc.loc_coord_ouom_code= 24 then 32617
when dloc.loc_coord_ouom_code= 25 then null
when dloc.loc_coord_ouom_code= 26 then 26917
when dloc.loc_coord_ouom_code= 27 then 26917
when dloc.loc_coord_ouom_code= 29 then null
when dloc.loc_coord_ouom_code= 31 then null
when dloc.loc_coord_ouom_code= 33 then null
when dloc.loc_coord_ouom_code= 35 then null
when dloc.loc_coord_ouom_code= 36 then 26917
else null
end as epsg_code_orig
,case
when dloc.loc_coord_ouom_code= 10 then 'UTM NAD83 specified; Z17 assumed'
when dloc.loc_coord_ouom_code= 11 then 'UTM NAD27 specified; Z17 assumed'
when dloc.loc_coord_ouom_code= 12 then 'UTM Z17 specified; NAD27 assumed'
when dloc.loc_coord_ouom_code= 13 then 'MTM specified; Z10 and NAD83 assumed'
when dloc.loc_coord_ouom_code= 20 then 'Lat/Long, Z17 specified; NAD83 assumed'
when dloc.loc_coord_ouom_code= 21 then 'Lat/Long specified; NAD83 assumed'
when dloc.loc_coord_ouom_code= 22 then 'Z17 specified; UTM and NAD83 assumed'
when dloc.loc_coord_ouom_code= 23 then 'Z18 specified; UTM and NAD83 assumed'
when dloc.loc_coord_ouom_code= 26 then 'EPSG_CODE 26911 specified; 26917 assumed'
when dloc.loc_coord_ouom_code= 27 then 'EPSG_CODE 26902 specified; 26917 assumed'
when dloc.loc_coord_ouom_code= 36 then 'UTM Z17 and NAD83 assumed'
else null
end as epsg_code_comment
,dlqa.qa_coord_confidence_code as qa_coord_code
,case
when dlqa.qa_coord_method is null then ''
else rtrim(dlqa.qa_coord_method) + '; '
end
+ 
case
when dlch.coord_hist_loc_method is null then ''
else rtrim(dlch.coord_hist_loc_method) + '; '
end
as loc_coord_method
,case
when dloc.loc_coord_comment is null then ''
else rtrim(dloc.loc_coord_comment) + '; '
end
+
-- dlch.coord_hist_comment
case
when dlch.coord_hist_comment is null then ''
else rtrim(dlch.coord_hist_comment) + '; '
end 
+
-- dlqa.qa_coord_source
case
when dlqa.qa_coord_source is null then ''
else rtrim(dlqa.qa_coord_source) + '; '
end
+
-- dlqa.qa_coord_comment
case
when dlqa.qa_coord_comment is null then ''
else rtrim(dlqa.qa_coord_comment) + '; '
end
as loc_coord_comment
,dlch.data_id as loc_coord_data_id
,case
when dleh.loc_elev_code is not null then dleh.loc_elev_code
else null
end as loc_elev_code
,case
when dleh.loc_elev_hist_date is not null then dleh.loc_elev_hist_date
when dleh.sys_time_stamp is not null then dleh.sys_time_stamp
else cast( null as datetime )
end as loc_elev_date
,delev.assigned_elev as loc_elev
,6 as loc_elev_unit_code
,delev.assigned_elev as loc_elev_ouom
,'masl' as loc_elev_unit_ouom
,case
when dlqa.qa_elev_confidence_code is not null then dlqa.qa_elev_confidence_code
when dleh.qa_elev_confidence_code is not null then dleh.qa_elev_confidence_code
when delev.assigned_elev is not null then 10
else null
end as qa_elev_code
,case
when dlqa.qa_elev_method is null then ''
else rtrim(dlqa.qa_elev_method) + '; '
end
as loc_elev_method
,case
when dlqa.qa_elev_source is null then ''
else rtrim(dlqa.qa_elev_source) + '; '
end 
+
case
when dlqa.qa_elev_comment is null then ''
else rtrim(dlqa.qa_elev_comment) + '; '
end
+ 
case
when dleh.elev_hist_comment is null then ''
else rtrim(dleh.elev_hist_comment) + '; '
end
as loc_elev_comment
,dleh.data_id as loc_elev_data_id
,cast('20200714a' as varchar(255)) as sys_temp1
,cast(20200714 as int) as sys_temp2
--,null as sys_last_modified_by
,case
when dleh.sys_last_modified>dloc.sys_last_modified then dleh.sys_last_modified_by
else dloc.sys_last_modified_by
end as sys_last_modified_by
--,null as sys_last_modified
,case
when dleh.sys_last_modified>dloc.sys_last_modified then dleh.sys_last_modified
else dloc.sys_last_modified
end as sys_last_modified
--,null as sys_user_stamp
,case
--when dlch.sys_user_stamp is not null then dlch.sys_user_stamp
when dloc.sys_last_modified_by is not null then dloc.sys_last_modified_by
else null
end as sys_user_stamp
--,null as sys_time_stamp
,case
when dlch.sys_time_stamp is not null then dlch.sys_time_stamp
when dloc.sys_last_modified is not null then dloc.sys_last_modified
else null
end as sys_time_stamp
from 
d_location as dloc
left outer join d_location_elev as delev
on dloc.loc_id=delev.loc_id
left outer join d_location_elev_hist as dleh
on delev.loc_elev_id=dleh.loc_elev_id
left outer join d_location_coord_hist as dlch
on dloc.loc_id=dlch.loc_id
left outer join d_location_qa as dlqa
on dloc.loc_id=dlqa.loc_id
where 
dlch.current_coord= 1

The resultant information is inserted into D_LOCATION_SPATIAL_HIST (not shown).  As these are the most current coordinates, the SPAT_ID from these records are used to update D_LOCATION_SPATIAL which is used to flag the 'current' coordinates for a particular location.

insert into d_location_spatial
( loc_id, spat_id, spatial_comment, sys_temp1, sys_temp2 )
select
loc_id
,spat_id
,'Initial assignment 20200714'
,'20200714a' as sys_temp1
,20200714 as sys_temp2
from 
d_location_spatial_hist

During this process, it was noted that some locations had been added to which the coordinates and/or elevations had not been captured.  Include these.

select
dloc.loc_id
,1 as loc_coord_hist_code
,case
when dloc.sys_last_modified is not null then dloc.sys_last_modified
else getdate()
end as loc_coord_date
,dloc.loc_coord_easting as x
,dloc.loc_coord_northing as y
,26917 as epsg_code
,dloc.loc_coord_easting_ouom as x_ouom
,dloc.loc_coord_northing_ouom as y_ouom
,case
when dloc.loc_coord_ouom_code=  4 then 26917
when dloc.loc_coord_ouom_code= 12 then 26717
when dloc.loc_coord_ouom_code= 21 then 4269
else null
end as epsg_code_orig
,case
when dloc.loc_coord_ouom_code= 12 then 'UTM Z17 specified; NAD27 assumed'
when dloc.loc_coord_ouom_code= 21 then 'Lat/Long specified; NAD83 assumed'
else null
end as epsg_code_comment
,case 
when dlqa.qa_coord_confidence_code is not null then dlqa.qa_coord_confidence_code
else 5
end 
as qa_coord_code
,case
when dlqa.qa_coord_method is null then ''
else rtrim(dlqa.qa_coord_method) + '; '
end
as loc_coord_method
,case
when dloc.loc_coord_comment is null then ''
else rtrim(dloc.loc_coord_comment) + '; '
end
+
-- dlqa.qa_coord_source
case
when dlqa.qa_coord_source is null then ''
else rtrim(dlqa.qa_coord_source) + '; '
end
+
-- dlqa.qa_coord_comment
case
when dlqa.qa_coord_comment is null then ''
else rtrim(dlqa.qa_coord_comment) + '; '
end
as loc_coord_comment
,case
when dleh.loc_elev_code is not null then dleh.loc_elev_code
else null
end as loc_elev_code
,case
when dleh.loc_elev_hist_date is not null then dleh.loc_elev_hist_date
when dleh.sys_time_stamp is not null then dleh.sys_time_stamp
else cast( null as datetime )
end as loc_elev_date
,delev.assigned_elev as loc_elev
,6 as loc_elev_unit_code
,delev.assigned_elev as loc_elev_ouom
,'masl' as loc_elev_unit_ouom
,case
when dlqa.qa_elev_confidence_code is not null then dlqa.qa_elev_confidence_code
when dleh.qa_elev_confidence_code is not null then dleh.qa_elev_confidence_code
when delev.assigned_elev is not null then 10
else null
end as qa_elev_code
,case
when dlqa.qa_elev_method is null then ''
else rtrim(dlqa.qa_elev_method) + '; '
end
as loc_elev_method
,case
when dlqa.qa_elev_source is null then ''
else rtrim(dlqa.qa_elev_source) + '; '
end 
+
case
when dlqa.qa_elev_comment is null then ''
else rtrim(dlqa.qa_elev_comment) + '; '
end
+ 
case
when dleh.elev_hist_comment is null then ''
else rtrim(dleh.elev_hist_comment) + '; '
end
as loc_elev_comment
,cast('20200714b' as varchar(255)) as sys_temp1
,cast(20200714 as int) as sys_temp2
,case
when dleh.sys_last_modified>dloc.sys_last_modified then dleh.sys_last_modified_by
else dloc.sys_last_modified_by
end as sys_last_modified_by
--,null as sys_last_modified
,case
when dleh.sys_last_modified>dloc.sys_last_modified then dleh.sys_last_modified
else dloc.sys_last_modified
end as sys_last_modified
--,null as sys_user_stamp
,case
when dloc.sys_last_modified_by is not null then dloc.sys_last_modified_by
when dloc.sys_user_stamp is not null then dloc.sys_user_stamp
else null
end as sys_user_stamp
,case
when dloc.sys_last_modified is not null then dloc.sys_last_modified
when dloc.sys_time_stamp is not null then dloc.sys_time_stamp
else null
end as sys_time_stamp
from 
d_location as dloc
left outer join d_location_qa as dlqa
on dloc.loc_id=dlqa.loc_id
left outer join d_location_elev as delev
on dloc.loc_id=delev.loc_id
left outer join d_location_elev_hist as dleh
on delev.loc_elev_id=dleh.loc_elev_id
left outer join d_location_spatial as dls
on dloc.loc_id=dls.loc_id
where 
dls.loc_id is null
and dloc.loc_coord_easting is not null
and dloc.loc_coord_northing is not null

Note that only a subset of the LOC_COORD_OUOM_CODE values were processed in this case.

Now that we've processed the 'current' coordinates, process those coordinates that have an associated elevation.  This only uses D_LOCATION_COORD_HIST and D_LOCATION_ELEV_HIST as a source.

select
dlch.loc_id
,case
when dlch.loc_coord_hist_code is not null then dlch.loc_coord_hist_code
else 1
end as loc_coord_hist_code
,case
when dlch.sys_time_stamp is not null then dlch.sys_time_stamp
else getdate()
end as loc_coord_date
,dlch.x_utmz17nad83 as x
,dlch.y_utmz17nad83 as y
,cast(26917 as int) as epsg_code
,case
-- the original coordinates in these cases are invalid
when dlch.loc_coord_ouom_code in ( 25, 29, 31, 33, 35 ) then null
else dlch.x_ouom
end as x_ouom
,case 
-- the original coordinates in these cases are invalid
when dlch.loc_coord_ouom_code in ( 25, 29, 31, 33, 35 ) then null
else dlch.y_ouom
end as y_ouom
,case
when dlch.loc_coord_ouom_code=  1 then null
when dlch.loc_coord_ouom_code=  2 then 26717
when dlch.loc_coord_ouom_code=  3 then 26718
when dlch.loc_coord_ouom_code=  4 then 26917
when dlch.loc_coord_ouom_code=  5 then 26918
when dlch.loc_coord_ouom_code=  6 then 26910
when dlch.loc_coord_ouom_code=  7 then 26915
when dlch.loc_coord_ouom_code=  8 then 26916
when dlch.loc_coord_ouom_code=  9 then 26919
when dlch.loc_coord_ouom_code= 10 then 26917
when dlch.loc_coord_ouom_code= 11 then 26717
when dlch.loc_coord_ouom_code= 12 then 26717
when dlch.loc_coord_ouom_code= 13 then 32190
when dlch.loc_coord_ouom_code= 14 then 7991
when dlch.loc_coord_ouom_code= 15 then 32190
when dlch.loc_coord_ouom_code= 16 then 32196
when dlch.loc_coord_ouom_code= 17 then 26917
when dlch.loc_coord_ouom_code= 18 then 4267
when dlch.loc_coord_ouom_code= 19 then 4269
when dlch.loc_coord_ouom_code= 20 then 4269
when dlch.loc_coord_ouom_code= 21 then 4269
when dlch.loc_coord_ouom_code= 22 then 26917
when dlch.loc_coord_ouom_code= 23 then 26918
when dlch.loc_coord_ouom_code= 24 then 32617
when dlch.loc_coord_ouom_code= 25 then null
when dlch.loc_coord_ouom_code= 26 then 26917
when dlch.loc_coord_ouom_code= 27 then 26917
when dlch.loc_coord_ouom_code= 29 then null
when dlch.loc_coord_ouom_code= 31 then null
when dlch.loc_coord_ouom_code= 33 then null
when dlch.loc_coord_ouom_code= 35 then null
when dlch.loc_coord_ouom_code= 36 then 26917
else null
end as epsg_code_orig
,case
when dlch.loc_coord_ouom_code= 10 then 'UTM NAD83 specified; Z17 assumed'
when dlch.loc_coord_ouom_code= 11 then 'UTM NAD27 specified; Z17 assumed'
when dlch.loc_coord_ouom_code= 12 then 'UTM Z17 specified; NAD27 assumed'
when dlch.loc_coord_ouom_code= 13 then 'MTM specified; Z10 and NAD83 assumed'
when dlch.loc_coord_ouom_code= 20 then 'Lat/Long, Z17 specified; NAD83 assumed'
when dlch.loc_coord_ouom_code= 21 then 'Lat/Long specified; NAD83 assumed'
when dlch.loc_coord_ouom_code= 22 then 'Z17 specified; UTM and NAD83 assumed'
when dlch.loc_coord_ouom_code= 23 then 'Z18 specified; UTM and NAD83 assumed'
when dlch.loc_coord_ouom_code= 26 then 'EPSG_CODE 26911 specified; 26917 assumed'
when dlch.loc_coord_ouom_code= 27 then 'EPSG_CODE 26902 specified; 26917 assumed'
when dlch.loc_coord_ouom_code= 36 then 'UTM Z17 and NAD83 assumed'
else null
end as epsg_code_comment
,dlch.qa_coord_confidence_code as qa_coord_code
,dlch.coord_hist_loc_method as loc_coord_method
,dlch.coord_hist_comment as loc_coord_comment
,dlch.data_id as loc_coord_data_id
,dleh.loc_elev_code
,case
when dleh.loc_elev_hist_date is not null then dleh.loc_elev_hist_date
else dleh.sys_time_stamp
end as loc_elev_date
,dleh.loc_elev_masl as loc_elev
,6 as loc_elev_unit_code
,dleh.loc_elev_masl as loc_elev_ouom
,'masl' as loc_elev_unit_ouom
,null as loc_elev_method
,rtrim(dleh.elev_hist_comment) as loc_elev_comment
,dleh.data_id as loc_elev_data_id
,cast('20200714c' as varchar(255)) as sys_temp1
,cast(20200714 as int) as sys_temp2
,case
when dleh.sys_last_modified>dlch.sys_last_modified then dleh.sys_last_modified_by
else dlch.sys_last_modified_by
end as sys_last_modified_by
,case
when dleh.sys_last_modified>dlch.sys_last_modified then dleh.sys_last_modified
else dlch.sys_last_modified
end as sys_last_modified
,case
when dlch.sys_user_stamp is not null then dlch.sys_user_stamp
when dleh.sys_user_stamp is not null then dleh.sys_user_stamp
else null
end as sys_user_stamp
,case
when dlch.sys_time_stamp is not null then dlch.sys_time_stamp
when dleh.sys_time_stamp is not null then dleh.sys_time_stamp
else null
end as sys_time_stamp
from 
d_location_coord_hist as dlch
inner join d_location_elev_hist as dleh
on dlch.loc_elev_id=dleh.loc_elev_id
where
dlch.current_coord is null

We can now look at the records from each of the D_LOCATION_COORD_HIST and D_LOCATION_ELEV_HIST that are unrelated (through a LOC_ELEV_ID); each of these will be handled separately.  Examining the former, there appears to be less than 500 records with a subset of information available.

select
loc_id
,loc_coord_hist_code
,sys_time_stamp as loc_coord_date
,x_utmz17nad83 as x
,y_utmz17nad83 as y
,26917 as epsg_code
,x_ouom 
,y_ouom
,case
when dlch.loc_coord_ouom_code=  3 then 26718
when dlch.loc_coord_ouom_code=  4 then 26917
when dlch.loc_coord_ouom_code=  5 then 26918
when dlch.loc_coord_ouom_code= 12 then 26717
when dlch.loc_coord_ouom_code= 17 then 26917
when dlch.loc_coord_ouom_code= 21 then 4269
when dlch.loc_coord_ouom_code= 22 then 26917
when dlch.loc_coord_ouom_code= 24 then 32617
when dlch.loc_coord_ouom_code= 36 then 26917
else null
end as epsg_code_orig
,qa_coord_confidence_code as qa_coord_code 
,'No associated elevation specified' as loc_elev_comment
,'20200714d' as sys_temp1
,20200714 as sys_temp2
,sys_last_modified
,sys_last_modified_by
,sys_time_stamp
,sys_user_stamp
from 
d_location_coord_hist as dlch
where 
dlch.current_coord is null
and dlch.loc_elev_id is null

The elevation history table has many more records (due, mainly, to the disparate DEM surfaces referenced).

select
loc_id
,'No associated coordinates specified' as loc_coord_comment
,loc_elev_code
,case
when loc_elev_hist_date is not null then loc_elev_hist_date
else sys_time_stamp
end as loc_elev_date
,loc_elev_masl as loc_elev
,6 as loc_elev_unit_code
,loc_elev_masl as loc_elev_ouom
,'masl' as loc_elev_unit_ouom
,qa_elev_confidence_code as qa_elev_code
,elev_hist_comment as loc_elev_comment
,'20200714e' as sys_temp1
,20200714 as sys_temp2
,sys_last_modified
,sys_last_modified_by
,sys_time_stamp
,sys_user_stamp
from 
d_location_elev_hist as dleh
left outer join 
(
select
delev.loc_elev_id as p_loc_elev_id
from 
d_location_elev as delev
union 
select
dlch.loc_elev_id as p_loc_elev_id
from 
d_location_coord_hist as dlch
where 
dlch.loc_elev_id is not null
) as t
on dleh.loc_elev_id=t.p_loc_elev_id
where
t.p_loc_elev_id is null

Now for those locations that only have a single coordinate, we can associate those coordinates with these newly added elevations (that lack coordinates).  This leaves approximately 50,000 records without related coordinates or elevations.

update d_location_spatial_hist
set
loc_coord_hist_code= t2.loc_coord_hist_code
,loc_coord_date= t2.loc_coord_date
,x= t2.x
,y= t2.y
,epsg_code= t2.epsg_code
,x_ouom= t2.x_ouom
,y_ouom= t2.y_ouom
,epsg_code_orig= t2.epsg_code_orig
,epsg_code_comment= t2.epsg_code_comment
,qa_coord_code= t2.qa_coord_code
,loc_coord_method= t2.loc_coord_method
,loc_coord_comment= t2.loc_coord_comment
,sys_temp1= t2.sys_temp1
from 
d_location_spatial_hist as dlsh2
inner join
(
select
dlsh.loc_id
,dlsh.spat_id
,dlch.loc_coord_hist_code
,dlch.sys_time_stamp as loc_coord_date
,dlch.x_utmz17nad83 as x
,dlch.y_utmz17nad83 as y
,26917 as epsg_code
,dlch.x_ouom 
,dlch.y_ouom
,case
when dlch.loc_coord_ouom_code=  1 then null
when dlch.loc_coord_ouom_code=  2 then 26717
when dlch.loc_coord_ouom_code=  3 then 26718
when dlch.loc_coord_ouom_code=  4 then 26917
when dlch.loc_coord_ouom_code=  5 then 26918
when dlch.loc_coord_ouom_code=  6 then 26910
when dlch.loc_coord_ouom_code=  7 then 26915
when dlch.loc_coord_ouom_code=  8 then 26916
when dlch.loc_coord_ouom_code=  9 then 26919
when dlch.loc_coord_ouom_code= 10 then 26917
when dlch.loc_coord_ouom_code= 11 then 26717
when dlch.loc_coord_ouom_code= 12 then 26717
when dlch.loc_coord_ouom_code= 13 then 32190
when dlch.loc_coord_ouom_code= 14 then 7991
when dlch.loc_coord_ouom_code= 15 then 32190
when dlch.loc_coord_ouom_code= 16 then 32196
when dlch.loc_coord_ouom_code= 17 then 26917
when dlch.loc_coord_ouom_code= 18 then 4267
when dlch.loc_coord_ouom_code= 19 then 4269
when dlch.loc_coord_ouom_code= 20 then 4269
when dlch.loc_coord_ouom_code= 21 then 4269
when dlch.loc_coord_ouom_code= 22 then 26917
when dlch.loc_coord_ouom_code= 23 then 26918
when dlch.loc_coord_ouom_code= 24 then 32617
when dlch.loc_coord_ouom_code= 25 then null
when dlch.loc_coord_ouom_code= 26 then 26917
when dlch.loc_coord_ouom_code= 27 then 26917
when dlch.loc_coord_ouom_code= 29 then null
when dlch.loc_coord_ouom_code= 31 then null
when dlch.loc_coord_ouom_code= 33 then null
when dlch.loc_coord_ouom_code= 35 then null
when dlch.loc_coord_ouom_code= 36 then 26917
else null
end as epsg_code_orig
,case
when dlch.loc_coord_ouom_code= 10 then 'UTM NAD83 specified; Z17 assumed'
when dlch.loc_coord_ouom_code= 11 then 'UTM NAD27 specified; Z17 assumed'
when dlch.loc_coord_ouom_code= 12 then 'UTM Z17 specified; NAD27 assumed'
when dlch.loc_coord_ouom_code= 13 then 'MTM specified; Z10 and NAD83 assumed'
when dlch.loc_coord_ouom_code= 20 then 'Lat/Long, Z17 specified; NAD83 assumed'
when dlch.loc_coord_ouom_code= 21 then 'Lat/Long specified; NAD83 assumed'
when dlch.loc_coord_ouom_code= 22 then 'Z17 specified; UTM and NAD83 assumed'
when dlch.loc_coord_ouom_code= 23 then 'Z18 specified; UTM and NAD83 assumed'
when dlch.loc_coord_ouom_code= 26 then 'EPSG_CODE 26911 specified; 26917 assumed'
when dlch.loc_coord_ouom_code= 27 then 'EPSG_CODE 26902 specified; 26917 assumed'
when dlch.loc_coord_ouom_code= 36 then 'UTM Z17 and NAD83 assumed'
else null
end as epsg_code_comment
,dlch.qa_coord_confidence_code as qa_coord_code 
,dlch.coord_hist_loc_method as loc_coord_method
,dlch.coord_hist_comment as loc_coord_comment
,'20200714f' as sys_temp1
from 
d_location_spatial_hist as dlsh
inner join d_location_coord_hist as dlch
on dlsh.loc_id=dlch.loc_id
inner join
(
select
loc_id
,count(*) as rcount
from 
d_location_coord_hist
group by
loc_id
) as t
on dlch.loc_id=t.loc_id
where
t.rcount=1
and dlsh.sys_temp1='20200714e'
and dlsh.x is null and dlsh.y is null
) as t2
on dlsh2.spat_id=t2.spat_id


G.32 Automated Scripts (Listing and Calling Order)

Tables

    - D_BOREHOLE
    - D_INTERVAL_FORM_ASSIGN
    - D_INTERVAL_FORM_ASSIGN_FINAL
    - D_INTERVAL_MONITOR
    - D_INTERVAL_SUMMARY
    - D_INTERVAL_TEMPORAL_2
    - D_LOCATION_GEOM
    - D_LOCATION_SUMMARY
    - D_VERSION_STATUS
    - W_GENERAL
    - W_GENERAL_DOCUMENT
    - W_GENERAL_GW_LEVEL
    - W_GENERAL_LOC_MET
    - W_GENERAL_LOC_SW
    - W_GENERAL_OTHER
    - W_GENERAL_SCREEN
    - W_GEOLOGY_LAYER

Recurrence Time: Weekly 

A variety of automated updates are performed against the database on a weekly basis (beginning on Saturday and ending on Sunday; note that the start times, listed subsequently, are relative to midnight Saturday.)  These can be broken into the following general groups (as listed in processing order)

    - Update D_INTERVAL_FORM_ASSIGN (and related)
    - Update D_LOCATION_SUMMARY (location by area)
    - Update D_INTERVAL_SUMMARY
    - Update D_LOCATION_SUMMARY
    - Update D_LOCATION_GEOM
    - Update D_VERSION_STATUS
    - Miscellaneous updates
    - Update all W_GENERAL_* tables
    - Database backup (and restore)
    - Miscellaneous daily updates

G.32.1 Update D_INTERVAL_FORM_ASSIGN (and related)

Main Script: d_int_form_ass.bat
Starting Time: -05:30

The following scripts are called (listed in order of processing)

    - Removal of those INT_IDs not present in CM2004 (rem_from_difa_cm2004.bat)
    - Add INT_IDs present in CM2004 (add_to_difa_cm2004.bat)
    - Create a temporay table containing CM2004 information (tmp_cm2004_int.bat)
    - Update D_INTERVAL_FORM_ASSIGN for the CM2004 model and remove the temporary table (upd_diffa_cm2004.bat)

This is repeated for each geologic model being evaluated (currently WB2018 and YT32011).  This will have a similar naming structure as listed above.

The ASSIGNED_UNIT is then populated for each geologic model (upd_difa_au.bat).

The thicknesses for each aquifer unit for each geologic model is then determined for each interval/location using the following scripts

    - Get the CM2004 ORAC thickness (tmp_gl_cm2004_orac.bat)
    - Update the THICKNESS_M field for the applicable records (upd_difa_cm2004_orac.bat)
    - Get the CM2004 Thorncliffe thickness (tmp_gl_cm2004_thorn.bat)
    - Update the THICKNESS_M field for the applicable records (upd_difa_cm2004_thorn.bat)
    - Get the CM2004 Scarborough thickness (tmp_gl_cm2004_scar.bat)
    - Update the THICKNESS_M field for the applicable records (upd_difa_cm2004_scar.bat)
    - Get the CM2004 Channel Sand thickness (tmp_gl_cm2004_chansa.bat)
    - Update the THICKNESS_M field for the applicable records (upd_difa_cm2004_chansa.bat)

This is repeated for each geologic model and their associated aquifers (WB2018: ORAC, Thorncliffe and Scarborough; YT32011: ORAC, Thorncliffe, Scarborough and Channel Sands).  These will have a similar naming scheme to the above.

The values of specific capacity (SC_LPMM), transmissivity (T) and hydraulic conductivity (K) can then be calculated (upd_difa_calc_tk.bat).  The associated fields will be updated.

The D_INTERVAL_FORM_ASSIGN_FINAL table can be updated, including

    - Removal of INT_IDs (for those not found in D_INTERVAL_FORM_ASSIGN and will NULL values for OVERRIDE_UNIT and MANUAL_UNIT; rem_from_difa_f.bat)
    - Add missing INT_IDs (i.e. present in D_INTERVAL_FORM_ASSIGN and absent from D_INTERVAL_FORMA_ASSIGN_FINAL; add_to_difa_f.bat)
    - Update the ASSIGNED_UNIT field (upd_au_difa_f.bat)

G.32.2 Update D_LOCATION_SUMMARY (location by area)

Main Script: d_loc_summary_area.bat
Starting Time: 00:00

Each partner conservation area and region is examined and the associated records have their CA_AREA_ID, REG_AREA_ID and SWP_AREA_ID fields updated in D_LOCATION_SUMMARY.  This is determined using the following scripts (listed in order of processing)

    - CLOCA (cloca_area_d_loc_sum.bat)
    - CVC (cvc_area_d_loc_sum.bat)
    - Durham Region (durham_area_d_loc_sum.bat)
    - GRCA (grca_area_d_loc_sum.bat)
    - Halton Region (halton_area_d_loc_sum.bat)
    - KCA (kca_area_d_loc_sum.bat)
    - LSRCA (lsrca_area_d_loc_sum.bat)
    - LTRCA (ltrca_area_d_loc_sum.bat)
    - NVCA (nvca_area_d_loc_sum.bat)
    - ORVA (orca_area_d_loc_sum.bat)
    - Peel Region (peel_area_d_loc_sum.bat)
    - SWP CTC (swp_ctc_area_d_loc_sum.bat)
    - SWP LS (swp_ls_area_d_loc_sum.bat)
    - SWP Trent (swp_trent_area_d_loc_sum.bat)
    - City of Toronto (Toronto_area_d_loc_sum.bat)
    - TRCA (trca_area_d_loc_sum.bat)
    - York Region (York_area_d_loc_sum.bat)

G.32.3 Update D_INTERVAL_SUMMARY

Main Script: d_int_sum.bat
Starting Time: 02:00

Records and fields found in D_INTERVAL_SUMMARY (DIS) are now updated (in order of processing)

    - Add missing INT_IDs (add_to_d_int_sum.bat)
    - Remove INT_IDs not found in D_INTERVAL (rem_from_d_int_sum.bat)
    - Update water levels (update_d_int_sum_wl.bat)
    - Update manual water levels (update_d_int_sum_wl_man.bat)
    - Update logger water levels (update_d_int_sum_wl_log.bat)
    - Update average water levels (update_d_int_sum_wl_avg.bat)
    - Update water quality (update_d_int_sum_wa.bat)
    - Update water quality samples (update_d_int_sum_wq_samp.bat)
    - Update precipitation (update_d_int_sum_precip.bat)
    - Update pumping readings (update_d_int_sum_pump.bat)
    - Update pumping daily volumnes (update_d_int_sum_pump_daily_vol.bat)
    - Update streamflow readings (update_d_int_sum_sflow.bat)
    - Update specific capacity (update_d_int_sum_spec_cap.bat)
    - Update air temperature readings (update_d_int_sum_temp_air.bat)

G.32.4 Update D_LOCATION_SUMMARY

Main Script: d_loc.sum.bat
Starting Time: 02:30

Records and fields found in D_LOCATION_SUMMARY (DLS) are now updated (in order of processing)

    - Add missing LOC_IDs (add_to_d_loc_sum.bat)
    - Remove LOC_IDs not found in D_LOCATION (rem_from_d_loc_sum.bat)
    - Update deepest screen top elevation (update_d_loc_sum_deep_scr_top.bat)
    - Update number of geologic layers (update_d_loc_sum_geol_lay_num.bat)
    - Update number of monitors/screens present (update_d_loc_sum_mon_num.bat)
    - Update total number of water levels (update_d_loc_sum_wl_total.bat)
    - Update total number of water quality readings (update_d_loc_sum_wa_total.bat)
    - Update total number of water quality samples (update_d_loc_sum_wq_total_samp.bat)
    - Update total number of precipitation readings (update_d_loc_sum_precip_total.bat)
    - Update total number of pump readings (update_d_loc_sum_pump_total.bat)
    - Update total number of streamflow readings (update_d_loc_sum_sflow_total.bat)
    - Update minimum, maximum and average streamflow readings (update_d_loc_sum_sflow_avgminmax.bat)
    - Update soil readings (update_d_loc_sum_soil.bat)
    - Update air temperature (update_d_loc_sum_temp_air.bat)

G.32.5 Update D_LOCATION_GEOM

Main Script: d_loc_geom.bat
Starting Time: 03:00

Records and fields found in D_LOCATION_GEOM (DLG) are now updated (in order of processing)

    - Remove LOC_IDs missing from D_LOCATION (rem_from_d_loc_geom.bat)
    - Check current coordinates (in D_LOCATION) against the current calculated geometry (tag them as necessary; coord_check_d_loc_geom.bat)
    - Add any new LOC_IDs (add_to_d_loc_geom.bat)
    - Update any blank GEOM fields (upd_d_loc_geom.bat)
    - Update any blank GEOM_WKB fields (update_d_loc_geom_wkb.bat)

G.32.6 Miscellaneous updates

Main Script: various.bat
Starting Time: 03:30

A variety of checks and updates are performed here (in a number of tables, in order of processing)

    - Update locations in D_BOREHOLE that no longer have a bedrock formation (rem_bed_elev.bat)
    - Update locations in D_BOREHOLE that have a bedrock formation (upd_bed_elev.bat)
    - Add new LOC_IDs (including coordinates and elevations) to D_LOCATION_SPATIAL_HIST (add_to_d_loc_spat_hist.bat)
    - Update D_LOCATION_SPAT adding newly assigned coordinates and elevations (add_to_d_loc_spat.bat)
    - Update the LOC_ACTIVE field for PTTW locations (upd_pttw_active.bat)
    - Update the LOC_STATUS_CODE for climate stations (upd_climate_active.bat)
    - Update the LOC_STATUS_CODE for spotflow locations (upd_sw_spotflow_active.bat)
    - Update the LOC_STATUS_CODE for streamflow gauges (upd_sw_gauge_active.bat)
    - Update MON_TOP_DEPTH_M and MON_BOT_DEPTH_M in D_INTERVAL_MONITOR (upd_dim_depths.bat)
    - Update the reference elevations and stick-ups in D_INTERVAL_REF_ELEV based upon a change in REF_POINT (upd_dire_stick_up.bat)

G.32.7 Update all W_GENERAL_* tables 

Main Script: w_gen_all.bat
Starting Time: 04:00

The contents of all the W_GENERAL_* tables are removed and the tables re-populated (in order of processing)

    - Delete all rows in W_GENERAL (WG; rem_from_w_gen.bat)
    - Add all rows to WG (add_to_w_gen.bat)
    - Delete all rows in W_GENERAL_DOCUMENT (WGC; rem_from_w_gen_doc.bat)
    - Add all rows to WGC (add_to_w_gen_doc.bat)
    - Delete all rows in W_GENERAL_OTHER (WGO; rem_from_w_gen_other.bat)
    - Add all rows to WGO (add_to_w_gen_other.bat)
    - Modify STATUS of PTTW locations in WGO (update_w_gen_other_pttw_active.bat)
    - Delete all rows in W_GENERAL_SCREEN (WGS; rem_from_w_gen_scr.bat)
    - Add all rows to WGS (add_to_w_gen_scr.bat)
    - Delete all rows in W_GENERAL_GW_LEVEL (WGGL; rem_from_w_gen_gw_level.bat)
    - Add daily logger water levels to WGGL (add_to_w_gen_gw_level_log.bat)
    - Add all manual water levels to WGGL (add_to_w_gen_gw_level_man.bat)
    - Delete all rows in W_GENERAL_LOC_MET (WGLM; rem_from_w_gen_loc_met.bat)
    - Add all rows to WGLM (add_to_w_gen_loc_met.bat)
    - Delete all rows in W_GENERAL_LOC_SW (WGLS; rem_from_w_gen_loc_sw.bat)
    - Add all rows to WGLS (add_to_w_gen_loc_sw.bat)
    - Add URLs for non-MOE borehole PDFs (in W_GENERAL and W_GENERAL_SCREEN; upd_w_gen_nonmoe_bh_pdf.bat)
    - Update those locations that can be used for Piper plots (using the field WQ_CB_PIPER; upd_wq_cb_piper.bat)
    - Update SPEC_CAP_LPMM in W_GENERAL_SCREEN (upd_spec_cap_lpmm.bat)
    - Delete all rows from W_GEOLOGY_LAYER (WGL; rem_from_w_geol_lay.bat)
    - Add all rows to WGL (add_to_w_geol_lay.bat)
    - Create a temporary table containing shallow water levels (wls_create_tmp.bat)
    - Update SHALLOW_WL_MASL and SHALLOW_WL_DEPTH_M in W_GENERAL; drop the temporary table (wls_update.bat)

G.32.8 Update D_VERSION_STATUS

Main Script: d_var_stat.bat
Starting Time: 5:00

Records are added to the D_VERSION_STATUS table capturing the status of the database.  This includes:

    - Adding location type counts (add_loc_type_counts.bat)
    - Adding interval type counts (add_int_type_counts.bat)
    - Adding reading group type counts (add_group_type_counts.bat)

G.32.9 Database backup (and restore)

Main Script: see below
Starting Time: 12:00

Each of the following are processed (in turn) to backup the master database and make available the OAK_20160831_WEEKLY database.  This includes

    - Update the OAK_20160831_WEEKLY database from the backup of OAK_20160831_MASTER (db_restore.bat) [12:00]
    - Move the OAK_20160831_MASTER backup file to the B: drive on SQLSERVER2k16 (i.e. the temporary backup location; db_backup.bat) [14:00]
    - Modify the permissions of various users to allow full access to OAK_20160831_WEEKLY (db_restore_permissions.bat) [14:55]
    - Split the backup of the master database to allow easy transfer off-site (db_backup_split.bat) [15:30; now disabled]
    - Move the backup file of the master database to B:\backup (i.e. the final backup location; db_backup_final.bat)

G.32.10 Miscellaneous daily updates

Main script: various_daily.bat
Starting time (daily): 22:00 (10:00pm)

Each of the following is processed, in turn: 

    - Update those records in D_INTERVAL_TEMPORAL_2 that have 'cmap' or 'map' as their original RD_UNIT_OUOM value; converts these to 'mbref'

G.33 Update of D_AREA_GEOM

Tables 

    - D_AREA_GEOM

Views

    - V_SYS_AREA_GEOM_WKB

Estimated Recurrence Time: As required.

The D_AREA_GEOM contains the boundaries (as polygons) for the various partner agencies, the ORMGP study area as well as the extent of geologic and hydrogeologic models.  Many of these include a buffered region as well.  This information is stored in two columns: GEOM and GEOM_WKB.  The former holds the default 'geometry' type for Microsoft SQL Server while the latter has been stored in the 'Well Known Binary' format.

The GEOM field is populated through any external GIS software that supports the native geometry format.  The GEOM_WKB is then populated using V_SYS_AREA_GEOM_WKB (using GEOM as a source).

Projections can be checked through

select
area_id
,geom.STSrid
From
d_area_geom

which returns the EPSG projection numeric for each record/object.  This should conform to the code '26917' (UTM Zone 17, NAD83).  If these have been incorrectly assigned (from the external source), the specific records can be updated using

update d_area_geom
set
geom.STSrid= 26917
where
area_id= 76

The example here is updating the ORMGP Boundary 5km buffer layer.






